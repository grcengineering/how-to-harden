# AUTO-GENERATED by scripts/sync-packs-to-data.sh â€” do not edit manually
# Generated: 2026-02-24T15:25:45Z

"1.1":
  api:
    lang: "bash"
    filename: "hth-salesforce-1.01-enforce-mfa.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/salesforce/api/hth-salesforce-1.01-enforce-mfa.sh"
    excerpts:
      api-query-users-without-mfa:
        content: |
            # Query active users who do not have MFA enabled
            info "1.1 Querying active users without MFA..."
            MFA_QUERY="SELECT Id, Username, Name, Profile.Name, IsActive, UserPreferencesDisableMFAPrompt FROM User WHERE IsActive = true"
            USER_RESPONSE=$(sf_query "${MFA_QUERY}") || {
            fail "1.1 Failed to query user MFA status"
            increment_failed
            summary
            exit 0
            }
          
            TOTAL_USERS=$(echo "${USER_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
            info "1.1 Total active users: ${TOTAL_USERS}"
          
            # Identify users with MFA prompt disabled (potential bypass)
            MFA_DISABLED=$(echo "${USER_RESPONSE}" | jq '[.records[] | select(.UserPreferencesDisableMFAPrompt == true)]' 2>/dev/null || echo "[]")
            DISABLED_COUNT=$(echo "${MFA_DISABLED}" | jq 'length' 2>/dev/null || echo "0")
          
            if [ "${DISABLED_COUNT}" -gt 0 ]; then
            warn "1.1 Found ${DISABLED_COUNT} user(s) with MFA prompt disabled:"
            echo "${MFA_DISABLED}" | jq -r '.[] | "  - \(.Username) (\(.Name), Profile: \(.Profile.Name // "unknown"))"' 2>/dev/null || true
            else
            pass "1.1 No users have MFA prompt disabled"
            fi
      api-check-session-settings:
        content: |
            # Verify org-wide session security settings require MFA
            info "1.1 Checking org-wide session security level..."
            SESSION_QUERY="SELECT Id, Name, SessionSecurityLevel FROM Profile WHERE Name IN ('System Administrator', 'Standard User')"
            SESSION_RESPONSE=$(sf_query "${SESSION_QUERY}" 2>/dev/null || echo '{"records":[]}')
          
            PROFILE_COUNT=$(echo "${SESSION_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
            if [ "${PROFILE_COUNT}" -gt 0 ]; then
            info "1.1 Profile session security levels:"
            echo "${SESSION_RESPONSE}" | jq -r '.records[] | "  - \(.Name): Session Level = \(.SessionSecurityLevel // "Standard")"' 2>/dev/null || true
            else
            warn "1.1 Could not retrieve profile session settings"
            fi
      api-check-identity-verification:
        content: |
            # Query permission sets with "Manage Multi-Factor Authentication" enabled
            info "1.1 Checking permission sets for MFA management..."
            PERM_QUERY="SELECT Id, Label, PermissionsManageMultiFactorInUi FROM PermissionSet WHERE PermissionsManageMultiFactorInUi = true"
            PERM_RESPONSE=$(sf_query "${PERM_QUERY}" 2>/dev/null || echo '{"records":[]}')
          
            PERM_COUNT=$(echo "${PERM_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
            if [ "${PERM_COUNT}" -gt 0 ]; then
            pass "1.1 Found ${PERM_COUNT} permission set(s) with MFA management enabled"
            echo "${PERM_RESPONSE}" | jq -r '.records[] | "  - \(.Label)"' 2>/dev/null || true
            else
            warn "1.1 No permission sets with MFA management -- ensure MFA is enforced org-wide via Setup > Identity Verification"
            fi

"2.1":
  api:
    lang: "bash"
    filename: "hth-salesforce-2.01-restrict-api-ip-allowlisting.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/salesforce/api/hth-salesforce-2.01-restrict-api-ip-allowlisting.sh"
    excerpts:
      api-query-login-ip-ranges:
        content: |
            # Query all configured Login IP Ranges across profiles
            info "2.1 Querying Login IP Ranges by profile..."
            IP_QUERY="SELECT Id, ProfileId, Profile.Name, StartAddress, EndAddress, Description FROM LoginIpRange ORDER BY Profile.Name"
            IP_RESPONSE=$(sf_query "${IP_QUERY}") || {
            fail "2.1 Failed to query Login IP Ranges"
            increment_failed
            summary
            exit 0
            }
          
            RANGE_COUNT=$(echo "${IP_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
          
            if [ "${RANGE_COUNT}" -gt 0 ]; then
            pass "2.1 Found ${RANGE_COUNT} Login IP Range(s) configured"
            echo "${IP_RESPONSE}" | jq -r '.records[] | "  - Profile: \(.Profile.Name // "unknown") | \(.StartAddress) - \(.EndAddress) | \(.Description // "no description")"' 2>/dev/null || true
            else
            warn "2.1 No Login IP Ranges configured -- API access is unrestricted by IP"
            warn "2.1 NIST SC-7: Network boundary protection requires IP-based access controls"
            fi
      api-check-trusted-ip-ranges:
        content: |
            # Query Trusted IP Ranges (org-wide network access)
            info "2.1 Checking org-wide Trusted IP Ranges..."
            TRUSTED_QUERY="SELECT Id, StartAddress, EndAddress, Description FROM SecuritySettings"
            # Trusted IP ranges are in Network Access -- query via Setup API
            NETWORK_RESPONSE=$(sf_tooling_query "SELECT Id, StartAddress, EndAddress, Description FROM NetworkAccess" 2>/dev/null || echo '{"records":[]}')
          
            TRUSTED_COUNT=$(echo "${NETWORK_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
          
            if [ "${TRUSTED_COUNT}" -gt 0 ]; then
            info "2.1 Found ${TRUSTED_COUNT} Trusted IP Range(s) (org-wide):"
            echo "${NETWORK_RESPONSE}" | jq -r '.records[] | "  - \(.StartAddress) - \(.EndAddress) | \(.Description // "no description")"' 2>/dev/null || true
            else
            warn "2.1 No org-wide Trusted IP Ranges configured"
            fi
      api-audit-recent-login-ips:
        content: |
            # Audit recent login IPs to identify unexpected sources
            info "2.1 Auditing recent login source IPs (last 100 logins)..."
            LOGIN_QUERY="SELECT Id, UserId, LoginTime, SourceIp, Status, Application, LoginType FROM LoginHistory ORDER BY LoginTime DESC LIMIT 100"
            LOGIN_RESPONSE=$(sf_query "${LOGIN_QUERY}" 2>/dev/null || echo '{"records":[]}')
          
            LOGIN_COUNT=$(echo "${LOGIN_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
            if [ "${LOGIN_COUNT}" -gt 0 ]; then
            # Summarize unique source IPs
            UNIQUE_IPS=$(echo "${LOGIN_RESPONSE}" | jq -r '[.records[].SourceIp] | unique | .[]' 2>/dev/null || true)
            IP_COUNT=$(echo "${UNIQUE_IPS}" | grep -c . 2>/dev/null || echo "0")
            info "2.1 Found ${IP_COUNT} unique source IP(s) in last ${LOGIN_COUNT} logins:"
            echo "${UNIQUE_IPS}" | while read -r ip; do
              COUNT=$(echo "${LOGIN_RESPONSE}" | jq "[.records[] | select(.SourceIp == \"${ip}\")] | length" 2>/dev/null || echo "?")
              echo "  - ${ip} (${COUNT} logins)"
            done
          
            # Flag failed logins from unexpected IPs
            FAILED=$(echo "${LOGIN_RESPONSE}" | jq '[.records[] | select(.Status == "Failed")]' 2>/dev/null || echo "[]")
            FAILED_COUNT=$(echo "${FAILED}" | jq 'length' 2>/dev/null || echo "0")
            if [ "${FAILED_COUNT}" -gt 0 ]; then
              warn "2.1 Found ${FAILED_COUNT} failed login(s) -- review source IPs:"
              echo "${FAILED}" | jq -r '.[] | "  - \(.SourceIp) at \(.LoginTime) via \(.Application // "unknown")"' 2>/dev/null || true
            fi
            else
            warn "2.1 No login history available -- verify API token has login history read permissions"
            fi
  db:
    lang: "sql"
    filename: "hth-salesforce-2.01-detect-gainsight-blocks.sql"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/salesforce/db/hth-salesforce-2.01-detect-gainsight-blocks.sql"
    excerpts:
      db-detect-gainsight-blocks:
        content: |
            -- Query for blocked Gainsight login attempts
            SELECT Id, LoginTime, SourceIp, Status, Application
            FROM LoginHistory
            WHERE Application = 'Gainsight'
            AND Status = 'Failed'
            AND LoginTime = LAST_N_DAYS:7
  sigma:
    - lang: "yaml"
      filename: "hth-salesforce-2.01-ip-allowlist-changed.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/salesforce/siem/sigma/hth-salesforce-2.01-ip-allowlist-changed.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    EventType: 'SetupAuditTrail'
                    Action|contains:
                        - 'insertedLoginIpRange'
                        - 'deletedLoginIpRange'
                        - 'updatedLoginIpRange'
                        - 'insertedNetworkAccess'
                        - 'deletedNetworkAccess'
                condition: selection
              fields:
                - CreatedDate
                - CreatedByContext
                - Display
                - Section
                - DelegateUser
                - ResponsibleNamespacePrefix

"3.1":
  api:
    lang: "bash"
    filename: "hth-salesforce-3.01-audit-connected-app-scopes.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/salesforce/api/hth-salesforce-3.01-audit-connected-app-scopes.sh"
    excerpts:
      api-list-connected-apps:
        content: |
            # List all Connected Applications with OAuth settings
            info "3.1 Querying Connected Applications..."
            APP_QUERY="SELECT Id, Name, CreatedDate, CreatedBy.Name, LastModifiedDate FROM ConnectedApplication ORDER BY Name"
            APP_RESPONSE=$(sf_tooling_query "${APP_QUERY}") || {
            fail "3.1 Failed to query Connected Applications"
            increment_failed
            summary
            exit 0
            }
          
            APP_COUNT=$(echo "${APP_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
          
            if [ "${APP_COUNT}" -gt 0 ]; then
            info "3.1 Found ${APP_COUNT} Connected Application(s):"
            echo "${APP_RESPONSE}" | jq -r '.records[] | "  - \(.Name) (Created: \(.CreatedDate), By: \(.CreatedBy.Name // "unknown"))"' 2>/dev/null || true
            else
            info "3.1 No Connected Applications found"
            fi
      api-audit-oauth-tokens:
        content: |
            # Audit active OAuth access tokens to identify over-permissioned integrations
            info "3.1 Querying active OAuth tokens..."
            TOKEN_QUERY="SELECT Id, AppName, UserId, CreatedDate, LastUsedDate FROM OAuthToken ORDER BY LastUsedDate DESC NULLS LAST"
            TOKEN_RESPONSE=$(sf_query "${TOKEN_QUERY}" 2>/dev/null || echo '{"records":[],"totalSize":0}')
          
            TOKEN_COUNT=$(echo "${TOKEN_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
          
            if [ "${TOKEN_COUNT}" -gt 0 ]; then
            info "3.1 Found ${TOKEN_COUNT} active OAuth token(s):"
            echo "${TOKEN_RESPONSE}" | jq -r '.records[] | "  - \(.AppName // "unnamed") (Last Used: \(.LastUsedDate // "never"), Created: \(.CreatedDate))"' 2>/dev/null || true
          
            # Flag tokens not used in 90+ days
            STALE_QUERY="SELECT Id, AppName, UserId, CreatedDate, LastUsedDate FROM OAuthToken WHERE LastUsedDate < LAST_N_DAYS:90"
            STALE_RESPONSE=$(sf_query "${STALE_QUERY}" 2>/dev/null || echo '{"records":[],"totalSize":0}')
            STALE_COUNT=$(echo "${STALE_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
          
            if [ "${STALE_COUNT}" -gt 0 ]; then
              warn "3.1 Found ${STALE_COUNT} stale OAuth token(s) unused for 90+ days -- consider revoking:"
              echo "${STALE_RESPONSE}" | jq -r '.records[] | "  - \(.AppName // "unnamed") (Last Used: \(.LastUsedDate // "never"))"' 2>/dev/null || true
            else
              pass "3.1 No stale OAuth tokens found (all used within 90 days)"
            fi
            else
            info "3.1 No active OAuth tokens found"
            fi
      api-check-connected-app-policies:
        content: |
            # Check Connected App OAuth policies (admin approval, IP relaxation)
            info "3.1 Checking Connected App OAuth policies..."
            POLICY_QUERY="SELECT Id, Name, OptionsAllowAdminApprovedUsersOnly, OptionsRefreshTokenValidityMetric FROM ConnectedApplication"
            POLICY_RESPONSE=$(sf_tooling_query "${POLICY_QUERY}" 2>/dev/null || echo '{"records":[],"totalSize":0}')
          
            POLICY_COUNT=$(echo "${POLICY_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
          
            if [ "${POLICY_COUNT}" -gt 0 ]; then
            # Flag apps that do NOT require admin pre-authorization
            OPEN_APPS=$(echo "${POLICY_RESPONSE}" | jq '[.records[] | select(.OptionsAllowAdminApprovedUsersOnly != true)]' 2>/dev/null || echo "[]")
            OPEN_COUNT=$(echo "${OPEN_APPS}" | jq 'length' 2>/dev/null || echo "0")
          
            if [ "${OPEN_COUNT}" -gt 0 ]; then
              warn "3.1 Found ${OPEN_COUNT} Connected App(s) not requiring admin pre-authorization:"
              echo "${OPEN_APPS}" | jq -r '.[] | "  - \(.Name) -- set OAuth policy to 'Admin approved users are pre-authorized'"' 2>/dev/null || true
            else
              pass "3.1 All Connected Apps require admin pre-authorization"
            fi
            else
            info "3.1 No Connected App policy data available"
            fi
  sigma:
    - lang: "yaml"
      filename: "hth-salesforce-3.01-connected-app-scope-modified.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/salesforce/siem/sigma/hth-salesforce-3.01-connected-app-scope-modified.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection_app_change:
                    EventType: 'SetupAuditTrail'
                    Action|contains:
                        - 'createdConnectedApp'
                        - 'updatedConnectedApp'
                        - 'deletedConnectedApp'
                        - 'changedConnectedAppOauth'
                        - 'changedConnectedAppAttributes'
                selection_oauth_policy:
                    EventType: 'SetupAuditTrail'
                    Action|contains:
                        - 'changedOauthPolicy'
                        - 'updatedOauthToken'
                condition: selection_app_change or selection_oauth_policy
              fields:
                - CreatedDate
                - CreatedByContext
                - Display
                - Section
                - DelegateUser
                - ResponsibleNamespacePrefix

"5.1":
  api:
    lang: "bash"
    filename: "hth-salesforce-5.01-enable-event-monitoring.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/salesforce/api/hth-salesforce-5.01-enable-event-monitoring.sh"
    excerpts:
      api-check-event-log-files:
        content: |
            # Query available EventLogFile types to verify Event Monitoring is active
            info "5.1 Checking EventLogFile availability..."
            LOG_QUERY="SELECT Id, EventType, LogDate, LogFileLength FROM EventLogFile ORDER BY LogDate DESC LIMIT 50"
            LOG_RESPONSE=$(sf_query "${LOG_QUERY}") || {
            fail "5.1 Failed to query EventLogFile -- Event Monitoring may not be enabled"
            fail "5.1 Enable via Setup > Event Monitoring Settings or purchase Salesforce Shield"
            increment_failed
            summary
            exit 0
            }
          
            LOG_COUNT=$(echo "${LOG_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
          
            if [ "${LOG_COUNT}" -gt 0 ]; then
            pass "5.1 Event Monitoring is active -- found ${LOG_COUNT} recent log file(s)"
          
            # Summarize event types available
            EVENT_TYPES=$(echo "${LOG_RESPONSE}" | jq -r '[.records[].EventType] | unique | sort | .[]' 2>/dev/null || true)
            TYPE_COUNT=$(echo "${EVENT_TYPES}" | grep -c . 2>/dev/null || echo "0")
            info "5.1 ${TYPE_COUNT} event type(s) available:"
            echo "${EVENT_TYPES}" | while read -r etype; do
              echo "  - ${etype}"
            done
            else
            warn "5.1 No EventLogFile records found -- Event Monitoring may not be enabled"
            warn "5.1 Enable via Setup > Event Monitoring Settings"
            fi
      api-check-api-anomaly-events:
        content: |
            # Look for API-related event types indicating anomaly detection
            info "5.1 Checking for API anomaly event types..."
            API_LOG_QUERY="SELECT Id, EventType, LogDate, LogFileLength FROM EventLogFile WHERE EventType IN ('ApiTotalUsage', 'API', 'RestApi', 'BulkApi', 'Login', 'LoginAs') ORDER BY LogDate DESC LIMIT 20"
            API_LOG_RESPONSE=$(sf_query "${API_LOG_QUERY}" 2>/dev/null || echo '{"records":[],"totalSize":0}')
          
            API_LOG_COUNT=$(echo "${API_LOG_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
          
            if [ "${API_LOG_COUNT}" -gt 0 ]; then
            pass "5.1 Found ${API_LOG_COUNT} API-related event log(s)"
            echo "${API_LOG_RESPONSE}" | jq -r '.records[] | "  - \(.EventType) on \(.LogDate) (\(.LogFileLength) bytes)"' 2>/dev/null || true
            else
            warn "5.1 No API-related event logs found -- enable API event types in Event Monitoring"
            fi
      api-audit-failed-logins:
        content: |
            # Audit recent failed login attempts for suspicious activity
            info "5.1 Auditing recent failed login attempts..."
            FAILED_QUERY="SELECT Id, LoginTime, SourceIp, Status, Application, UserId, LoginType FROM LoginHistory WHERE Status = 'Failed' ORDER BY LoginTime DESC LIMIT 50"
            FAILED_RESPONSE=$(sf_query "${FAILED_QUERY}" 2>/dev/null || echo '{"records":[],"totalSize":0}')
          
            FAILED_COUNT=$(echo "${FAILED_RESPONSE}" | jq '.totalSize // 0' 2>/dev/null)
          
            if [ "${FAILED_COUNT}" -gt 0 ]; then
            warn "5.1 Found ${FAILED_COUNT} recent failed login attempt(s):"
          
            # Group by source IP for anomaly detection
            UNIQUE_FAIL_IPS=$(echo "${FAILED_RESPONSE}" | jq -r '[.records[].SourceIp] | unique | .[]' 2>/dev/null || true)
            echo "${UNIQUE_FAIL_IPS}" | while read -r ip; do
              COUNT=$(echo "${FAILED_RESPONSE}" | jq "[.records[] | select(.SourceIp == \"${ip}\")] | length" 2>/dev/null || echo "?")
              echo "  - ${ip}: ${COUNT} failed attempt(s)"
            done
          
            # Flag IPs with 5+ failures (brute force indicator)
            echo "${UNIQUE_FAIL_IPS}" | while read -r ip; do
              COUNT=$(echo "${FAILED_RESPONSE}" | jq "[.records[] | select(.SourceIp == \"${ip}\")] | length" 2>/dev/null || echo "0")
              if [ "${COUNT}" -ge 5 ]; then
                warn "5.1 ALERT: ${ip} has ${COUNT} failed logins -- possible brute force"
              fi
            done
            else
            pass "5.1 No recent failed login attempts found"
            fi
  sigma:
    - lang: "yaml"
      filename: "hth-salesforce-5.01-bulk-data-export-detected.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/salesforce/siem/sigma/hth-salesforce-5.01-bulk-data-export-detected.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection_bulk_api:
                    EventType:
                        - 'BulkApi'
                        - 'ApiBulkApiHard'
                selection_data_export:
                    EventType: 'DataExport'
                selection_large_query:
                    EventType:
                        - 'API'
                        - 'RestApi'
                    ROWS_PROCESSED|gte: 10000
                condition: selection_bulk_api or selection_data_export or selection_large_query
              fields:
                - EventDate
                - Username
                - SourceIp
                - ROWS_PROCESSED
                - ENTITY_NAME
                - CLIENT_NAME
                - REQUEST_STATUS

