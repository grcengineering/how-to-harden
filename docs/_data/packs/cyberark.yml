# AUTO-GENERATED by scripts/sync-packs-to-data.sh — do not edit manually
# Generated: 2026-02-19T16:51:14Z

"1.1":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-1.01-enforce-mfa.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-1.01-enforce-mfa.tf"
    excerpts:
      terraform:
        content: |
            # Configure RADIUS MFA authentication method via PVWA API
            resource "null_resource" "mfa_radius_config" {
            count = var.mfa_radius_server != "" ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/AuthenticationMethods/radius" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "id": "radius",
                    "displayName": "RADIUS MFA",
                    "enabled": true,
                    "settings": {
                      "server": "${var.mfa_radius_server}",
                      "port": ${var.mfa_radius_port},
                      "timeout": ${var.mfa_radius_timeout}
                    }
                  }'
              EOT
            }
          
            triggers = {
              radius_server  = var.mfa_radius_server
              radius_port    = var.mfa_radius_port
              radius_timeout = var.mfa_radius_timeout
            }
            }
          
            # L2+: Disable "Remember Device" for MFA to enforce every-session verification
            resource "null_resource" "mfa_disable_remember_device" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/AuthenticationMethods/radius" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "id": "radius",
                    "displayName": "RADIUS MFA",
                    "enabled": true,
                    "settings": {
                      "server": "${var.mfa_radius_server}",
                      "port": ${var.mfa_radius_port},
                      "timeout": ${var.mfa_radius_timeout},
                      "rememberDevice": false
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.mfa_radius_config]
          
            triggers = {
              profile_level = var.profile_level
            }
            }
  api:
    lang: "bash"
    filename: "hth-cyberark-1.01-configure-radius-mfa.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/api/hth-cyberark-1.01-configure-radius-mfa.sh"
    excerpts:
      api-configure-mfa:
        content: |
            # Configure RADIUS MFA authentication method via CyberArk REST API
            curl -X PUT "https://${PVWA_URL}/PasswordVault/API/Configuration/AuthenticationMethods/radius" \
            -H "Authorization: ${AUTH_TOKEN}" \
            -H "Content-Type: application/json" \
            -d '{
              "id": "radius",
              "displayName": "RADIUS MFA",
              "enabled": true,
              "settings": {
                "server": "mfa.company.com",
                "port": 1812,
                "timeout": 60
              }
            }'

"1.2":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-1.02-vault-level-access-controls.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-1.02-vault-level-access-controls.tf"
    excerpts:
      terraform:
        content: |
            # Create safes with granular access controls
            resource "null_resource" "create_safes" {
            for_each = var.safes
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X POST \
                  "${var.pvwa_url}/PasswordVault/API/Safes" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "safeName": "${each.key}",
                    "description": "${each.value.description}",
                    "olacEnabled": ${each.value.olac_enabled},
                    "managingCPM": "${each.value.managing_cpm}",
                    "numberOfVersionsRetention": ${each.value.retention_versions},
                    "numberOfDaysRetention": ${each.value.retention_days}
                  }'
              EOT
            }
          
            triggers = {
              safe_name   = each.key
              description = each.value.description
              olac        = each.value.olac_enabled
            }
            }
          
            # Add members to safes with least-privilege permissions
            resource "null_resource" "safe_members" {
            for_each = var.safe_members
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X POST \
                  "${var.pvwa_url}/PasswordVault/API/Safes/${each.value.safe_name}/Members" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "memberName": "${each.value.member_name}",
                    "memberType": "${each.value.member_type}",
                    "permissions": {
                      "useAccounts": ${each.value.use_accounts},
                      "retrieveAccounts": ${each.value.retrieve_accounts},
                      "listAccounts": ${each.value.list_accounts},
                      "addAccounts": ${each.value.add_accounts},
                      "updateAccountContent": ${each.value.update_accounts},
                      "deleteAccounts": ${each.value.delete_accounts},
                      "manageSafe": ${each.value.manage_safe},
                      "requestsAuthorizationLevel1": ${each.value.request_auth_level >= 1}
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.create_safes]
          
            triggers = {
              safe_name   = each.value.safe_name
              member_name = each.value.member_name
              permissions = jsonencode(each.value)
            }
            }
          
            # L2+: Enforce dual-control approval for sensitive safes
            resource "null_resource" "dual_control_policy" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/MasterPolicy" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "policyName": "DualControl",
                    "settings": {
                      "requireDualControlPasswordAccessApproval": true,
                      "enforceCheckInCheckOut": true,
                      "exclusiveAccess": true
                    }
                  }'
              EOT
            }
          
            triggers = {
              profile_level = var.profile_level
            }
            }
  api:
    lang: "bash"
    filename: "hth-cyberark-1.02-create-safe-with-permissions.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/api/hth-cyberark-1.02-create-safe-with-permissions.sh"
    excerpts:
      api-create-safe:
        content: |
            # Create safe with restricted access via REST API
            curl -X POST "https://${PVWA_URL}/PasswordVault/API/Safes" \
            -H "Authorization: ${AUTH_TOKEN}" \
            -H "Content-Type: application/json" \
            -d '{
              "safeName": "Windows-DomainAdmins",
              "description": "Domain Administrator credentials - requires approval",
              "olacEnabled": true,
              "managingCPM": "PasswordManager",
              "numberOfVersionsRetention": 10,
              "numberOfDaysRetention": 30
            }'
          
            # Add member with limited permissions
            curl -X POST "https://${PVWA_URL}/PasswordVault/API/Safes/Windows-DomainAdmins/Members" \
            -H "Authorization: ${AUTH_TOKEN}" \
            -H "Content-Type: application/json" \
            -d '{
              "memberName": "WindowsAdmins",
              "memberType": "Group",
              "permissions": {
                "useAccounts": true,
                "retrieveAccounts": true,
                "listAccounts": true,
                "addAccounts": false,
                "updateAccountContent": false,
                "deleteAccounts": false,
                "manageSafe": false,
                "requestsAuthorizationLevel1": true
              }
            }'
  cli:
    lang: "text"
    filename: "hth-cyberark-1.02-safe-structure.txt"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/cli/hth-cyberark-1.02-safe-structure.txt"
    excerpts:
      cli-safe-structure:
        content: |
            Safes/
            ├── Infrastructure/
            │   ├── Windows-DomainAdmins (requires approval)
            │   ├── Linux-Root
            │   └── Network-Devices
            ├── Applications/
            │   ├── Database-Credentials
            │   └── API-Keys
            └── Emergency/
              └── Break-Glass (requires dual approval)

"1.3":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-1.03-break-glass-procedures.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-1.03-break-glass-procedures.tf"
    excerpts:
      terraform:
        content: |
            # Create break-glass emergency safe with enhanced controls
            resource "null_resource" "break_glass_safe" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X POST \
                  "${var.pvwa_url}/PasswordVault/API/Safes" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "safeName": "${var.break_glass_safe_name}",
                    "description": "Emergency break-glass credentials - dual approval required",
                    "olacEnabled": true,
                    "managingCPM": "PasswordManager",
                    "numberOfVersionsRetention": 20,
                    "numberOfDaysRetention": 365
                  }'
              EOT
            }
          
            triggers = {
              safe_name = var.break_glass_safe_name
            }
            }
          
            # Configure dual-approval workflow for break-glass safe
            resource "null_resource" "break_glass_dual_approval" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Safes/${var.break_glass_safe_name}/Members" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "memberName": "BreakGlassApprovers",
                    "memberType": "Group",
                    "permissions": {
                      "useAccounts": false,
                      "retrieveAccounts": false,
                      "listAccounts": true,
                      "requestsAuthorizationLevel1": true,
                      "requestsAuthorizationLevel2": true,
                      "accessWithoutConfirmation": false
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.break_glass_safe]
          
            triggers = {
              safe_name      = var.break_glass_safe_name
              approval_count = var.break_glass_approval_count
            }
            }
          
            # L3: Enforce enhanced logging and shorter expiration for break-glass
            resource "null_resource" "break_glass_enhanced" {
            count = var.profile_level >= 3 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/MasterPolicy" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "policyName": "BreakGlassEnhanced",
                    "settings": {
                      "exclusiveAccess": true,
                      "requireDualControlPasswordAccessApproval": true,
                      "minApprovers": ${var.break_glass_approval_count},
                      "accessExpirationHours": ${var.break_glass_expiration_hours},
                      "enforceOneTimeAccess": true
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.break_glass_safe]
          
            triggers = {
              profile_level    = var.profile_level
              expiration_hours = var.break_glass_expiration_hours
            }
            }

"2.1":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-2.01-harden-vault-server.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-2.01-harden-vault-server.tf"
    excerpts:
      terraform:
        content: |
            # Verify and enforce vault encryption settings via DBParm configuration
            resource "null_resource" "vault_encryption_config" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X GET \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/Vault" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  | python3 -c "
            import sys, json
            config = json.load(sys.stdin)
            encryption = config.get('encryptionMethod', 'UNKNOWN')
            if encryption != 'AES256':
              print('WARNING: Encryption method is ' + encryption + ', expected AES256')
              sys.exit(1)
            print('OK: Vault encryption is AES256')
            "
              EOT
            }
          
            triggers = {
              check_interval = timestamp()
            }
            }
          
            # Enforce TLS 1.2+ for all vault communications
            resource "null_resource" "vault_tls_config" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/WebServices" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "minTlsVersion": "1.2",
                      "disableSSLv3": true,
                      "disableTLS10": true,
                      "disableTLS11": true
                    }
                  }'
              EOT
            }
          
            triggers = {
              tls_config = "tls12_enforced"
            }
            }
          
            # L3: Enforce TLS 1.3 only for maximum security
            resource "null_resource" "vault_tls13_only" {
            count = var.profile_level >= 3 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/WebServices" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "minTlsVersion": "1.3",
                      "disableSSLv3": true,
                      "disableTLS10": true,
                      "disableTLS11": true,
                      "disableTLS12": true
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.vault_tls_config]
          
            triggers = {
              profile_level = var.profile_level
            }
            }
  cli:
    lang: "ini"
    filename: "hth-cyberark-2.01-dbparm-encryption.ini"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/cli/hth-cyberark-2.01-dbparm-encryption.ini"
    excerpts:
      cli-dbparm-encryption:
        content: |
            [MAIN]
            EncryptionMethod=AES256
            ServerKeyAge=365
            BackupKeyAge=365

"2.2":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-2.02-vault-high-availability.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-2.02-vault-high-availability.tf"
    excerpts:
      terraform:
        content: |
            # L2+: Verify vault replication status
            resource "null_resource" "vault_replication_check" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X GET \
                  "${var.pvwa_url}/PasswordVault/API/ComponentMonitoring" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  | python3 -c "
            import sys, json
            data = json.load(sys.stdin)
            components = data.get('Components', [])
            dr_found = False
            for comp in components:
              if 'DR' in comp.get('ComponentName', ''):
                  dr_found = True
                  status = comp.get('IsLoggedOn', False)
                  print(f'DR Component: {comp[\"ComponentName\"]} - Connected: {status}')
            if not dr_found:
              print('WARNING: No DR vault component detected')
              sys.exit(1)
            print('OK: DR vault replication verified')
            "
              EOT
            }
          
            triggers = {
              check_interval = timestamp()
            }
            }
          
            # L2+: Configure backup verification schedule
            resource "null_resource" "vault_backup_verification" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/BackupSettings" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "backupEnabled": true,
                      "backupRetentionDays": ${var.audit_retention_days},
                      "verifyBackupIntegrity": true,
                      "encryptBackups": true
                    }
                  }'
              EOT
            }
          
            triggers = {
              retention_days = var.audit_retention_days
            }
            }
  cli:
    lang: "bash"
    filename: "hth-cyberark-2.02-dr-replication.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/cli/hth-cyberark-2.02-dr-replication.sh"
    excerpts:
      cli-dr-replication:
        content: |
            # Verify vault replication status
            PAReplicate.exe Status
          
            # Test DR failover (non-production)
            PAReplicate.exe Failover /target:DR_VAULT

"3.1":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-3.01-secure-api-authentication.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-3.01-secure-api-authentication.tf"
    excerpts:
      terraform:
        content: |
            # Enable certificate-based API authentication
            resource "null_resource" "api_cert_auth" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/ApiSettings" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "certificateAuthentication": true,
                      "clientCertificateRequired": true,
                      "caValidation": true
                    }
                  }'
              EOT
            }
          
            triggers = {
              cert_auth = "enabled"
            }
            }
          
            # Configure API rate limiting
            resource "null_resource" "api_rate_limiting" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/WebServices" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "maxConcurrentRequests": ${var.api_rate_limit_max_concurrent},
                      "requestTimeoutSeconds": ${var.api_rate_limit_timeout},
                      "enableRateLimiting": true
                    }
                  }'
              EOT
            }
          
            triggers = {
              max_concurrent = var.api_rate_limit_max_concurrent
              timeout        = var.api_rate_limit_timeout
            }
            }
          
            # Restrict API access to allowed IP addresses
            resource "null_resource" "api_ip_restrictions" {
            count = length(var.api_allowed_ips) > 0 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/ApiSettings" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "allowedSourceIPs": ${jsonencode(var.api_allowed_ips)},
                      "restrictByIP": true
                    }
                  }'
              EOT
            }
          
            triggers = {
              allowed_ips = jsonencode(var.api_allowed_ips)
            }
            }
          
            # L2+: Enforce short-lived API tokens with automatic expiration
            resource "null_resource" "api_token_expiration" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/ApiSettings" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "tokenMaxLifetimeMinutes": 60,
                      "requireTokenRefresh": true,
                      "singleUseTokens": false
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.api_cert_auth]
          
            triggers = {
              profile_level = var.profile_level
            }
            }
          
            # L3: Enforce single-use API tokens for maximum security
            resource "null_resource" "api_single_use_tokens" {
            count = var.profile_level >= 3 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/ApiSettings" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "tokenMaxLifetimeMinutes": 30,
                      "requireTokenRefresh": true,
                      "singleUseTokens": true
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.api_token_expiration]
          
            triggers = {
              profile_level = var.profile_level
            }
            }
  cli:
    lang: "ini"
    filename: "hth-cyberark-3.01-api-rate-limiting.ini"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/cli/hth-cyberark-3.01-api-rate-limiting.ini"
    excerpts:
      cli-api-rate-limiting:
        content: |
            # In PVConfiguration.xml
            <WebService>
            <MaxConcurrentRequests>50</MaxConcurrentRequests>
            <RequestTimeoutSeconds>120</RequestTimeoutSeconds>
            <EnableRateLimiting>true</EnableRateLimiting>
            </WebService>
  sdk:
    lang: "python"
    filename: "hth-cyberark-3.01-secure-api-authentication.py"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/sdk/hth-cyberark-3.01-secure-api-authentication.py"
    excerpts:
      sdk-cert-auth:
        content: |
            # Secure CyberArk API authentication using certificate
            import requests
          
            PVWA_URL = "https://pvwa.company.com"
            CERT_FILE = "/path/to/client.crt"
            KEY_FILE = "/path/to/client.key"
            CA_FILE = "/path/to/ca.crt"
          
            def get_api_token():
              """Authenticate to CyberArk using certificate"""
              response = requests.post(
                  f"{PVWA_URL}/PasswordVault/API/Auth/CyberArk/Logon",
                  cert=(CERT_FILE, KEY_FILE),
                  verify=CA_FILE,
                  json={
                      "username": "APIUser",
                      "password": ""  # Certificate-based, no password
                  }
              )
              return response.text.strip('"')
          
            def get_credential(token, safe, account):
              """Retrieve credential securely"""
              response = requests.get(
                  f"{PVWA_URL}/PasswordVault/API/Accounts?filter=safeName eq {safe}",
                  headers={"Authorization": token},
                  cert=(CERT_FILE, KEY_FILE),
                  verify=CA_FILE
              )
              return response.json()

"3.2":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-3.02-restrict-integration-permissions.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-3.02-restrict-integration-permissions.tf"
    excerpts:
      terraform:
        content: |
            # Create purpose-specific integration service accounts with least privilege
            resource "null_resource" "integration_service_accounts" {
            for_each = var.integration_users
          
            provisioner "local-exec" {
              command = <<-EOT
                # Create the integration user
                curl -sk -X POST \
                  "${var.pvwa_url}/PasswordVault/API/Users" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "username": "${each.key}",
                    "userType": "ServiceAccount",
                    "description": "Integration service account - least privilege",
                    "enableUser": true,
                    "authenticationMethod": ["CyberArk"]
                  }'
              EOT
            }
          
            triggers = {
              user_name = each.key
            }
            }
          
            # Grant integration users access to specific safes only
            resource "null_resource" "integration_safe_access" {
            for_each = var.integration_users
          
            provisioner "local-exec" {
              command = <<-EOT
                for SAFE in ${join(" ", each.value.safe_access)}; do
                  curl -sk -X POST \
                    "${var.pvwa_url}/PasswordVault/API/Safes/$SAFE/Members" \
                    -H "Authorization: ${var.pvwa_auth_token}" \
                    -H "Content-Type: application/json" \
                    -d '{
                      "memberName": "${each.key}",
                      "memberType": "User",
                      "permissions": {
                        "useAccounts": ${each.value.use_accounts},
                        "retrieveAccounts": ${each.value.retrieve},
                        "listAccounts": ${each.value.list_accounts},
                        "addAccounts": false,
                        "updateAccountContent": false,
                        "deleteAccounts": false,
                        "manageSafe": false,
                        "manageSafeMembers": false
                      }
                    }'
                done
              EOT
            }
          
            depends_on = [null_resource.integration_service_accounts]
          
            triggers = {
              user_name   = each.key
              safe_access = jsonencode(each.value.safe_access)
              permissions = jsonencode(each.value)
            }
            }
          
            # L2+: Enable audit logging for all integration account actions
            resource "null_resource" "integration_audit_enforcement" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/AuditSettings" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "auditServiceAccountActions": true,
                      "detailedIntegrationLogging": true,
                      "logRetrievalEvents": true,
                      "logConnectionEvents": true
                    }
                  }'
              EOT
            }
          
            triggers = {
              profile_level = var.profile_level
            }
            }
  cli:
    lang: "text"
    filename: "hth-cyberark-3.02-integration-users.txt"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/cli/hth-cyberark-3.02-integration-users.txt"
    excerpts:
      cli-integration-users:
        content: |
            Integration Users:
            ├── Svc-Jenkins: Access to Application-Secrets only
            ├── Svc-Ansible: Access to Infrastructure-Credentials only
            ├── Svc-Terraform: Access to Cloud-Credentials only
            └── Svc-SIEM: Audit log access only

"3.3":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-3.03-external-secrets-integration.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-3.03-external-secrets-integration.tf"
    excerpts:
      terraform:
        content: |
            # L2+: Configure Conjur policy for HashiCorp Vault integration
            resource "null_resource" "conjur_vault_integration_policy" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X POST \
                  "${var.conjur_appliance_url}/policies/${var.conjur_account}/policy/root" \
                  -H "Authorization: Token token=\"${var.conjur_api_key}\"" \
                  -H "Content-Type: application/x-yaml" \
                  -d '
            ---
            - !policy
            id: integrations/hashicorp-vault
            body:
              - !host
                id: vault-sync
                annotations:
                  description: HashiCorp Vault integration for secrets synchronization
                  authn/api-key: true
              - !permit
                role: !host vault-sync
                privileges: [read, execute]
                resource: !variable secrets/*
              - !grant
                role: !group integrations/readers
                member: !host vault-sync
            '
              EOT
            }
          
            triggers = {
              policy_version = "v1"
            }
            }
          
            # L2+: Configure Conjur policy for AWS Secrets Manager integration
            resource "null_resource" "conjur_aws_integration_policy" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X POST \
                  "${var.conjur_appliance_url}/policies/${var.conjur_account}/policy/root" \
                  -H "Authorization: Token token=\"${var.conjur_api_key}\"" \
                  -H "Content-Type: application/x-yaml" \
                  -d '
            ---
            - !policy
            id: integrations/aws-secrets-manager
            body:
              - !host
                id: aws-sync
                annotations:
                  description: AWS Secrets Manager integration for secrets synchronization
                  authn/api-key: true
              - !permit
                role: !host aws-sync
                privileges: [read]
                resource: !variable secrets/aws/*
              - !grant
                role: !group integrations/readers
                member: !host aws-sync
            '
              EOT
            }
          
            triggers = {
              policy_version = "v1"
            }
            }
          
            # L3: Configure Conjur policy restricting integration sync to specific secrets
            resource "null_resource" "conjur_restricted_sync_policy" {
            count = var.profile_level >= 3 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X POST \
                  "${var.conjur_appliance_url}/policies/${var.conjur_account}/policy/root" \
                  -H "Authorization: Token token=\"${var.conjur_api_key}\"" \
                  -H "Content-Type: application/x-yaml" \
                  -d '
            ---
            - !policy
            id: integrations/restrictions
            body:
              - !deny
                role: !group integrations/readers
                privileges: [read, execute]
                resource: !variable secrets/critical/*
              - !deny
                role: !group integrations/readers
                privileges: [read, execute]
                resource: !variable secrets/break-glass/*
            '
              EOT
            }
          
            depends_on = [
              null_resource.conjur_vault_integration_policy,
              null_resource.conjur_aws_integration_policy
            ]
          
            triggers = {
              profile_level = var.profile_level
            }
            }
  api:
    lang: "bash"
    filename: "hth-cyberark-3.03-configure-external-secrets.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/api/hth-cyberark-3.03-configure-external-secrets.sh"
    excerpts:
      api-external-secrets:
        content: |
            # Configure Vault to retrieve from CyberArk
            vault write auth/approle/role/cyberark \
              token_policies="cyberark-read" \
              token_ttl=1h \
              token_max_ttl=4h
          
            # CyberArk Secrets Hub configuration
            # Sync secrets to Vault while maintaining CyberArk as source of truth
  sdk:
    lang: "python"
    filename: "hth-cyberark-3.03-sync-to-aws-secrets.py"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/sdk/hth-cyberark-3.03-sync-to-aws-secrets.py"
    excerpts:
      sdk-aws-secrets-sync:
        content: |
            # Sync CyberArk credentials to AWS Secrets Manager
            import boto3
            from cyberark import CyberArkClient
          
            def sync_to_aws_secrets(cyberark_client, aws_region):
              secrets_client = boto3.client('secretsmanager', region_name=aws_region)
          
              credentials = cyberark_client.get_credentials(safe="AWS-Credentials")
          
              for cred in credentials:
                  secrets_client.update_secret(
                      SecretId=cred['name'],
                      SecretString=cred['password']
                  )

"4.1":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-4.01-psm-session-security.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-4.01-psm-session-security.tf"
    excerpts:
      terraform:
        content: |
            # Enable session recording for all PSM platforms
            resource "null_resource" "psm_session_recording" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/PlatformConfiguration" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "sessionRecording": ${var.session_recording_enabled},
                      "recordingFormat": "Universal",
                      "recordingEncryption": true
                    }
                  }'
              EOT
            }
          
            triggers = {
              recording_enabled = var.session_recording_enabled
            }
            }
          
            # Configure session timeouts
            resource "null_resource" "psm_session_timeouts" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/PlatformConfiguration" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "maxSessionDuration": ${var.session_max_duration_minutes},
                      "idleSessionTimeout": ${var.session_idle_timeout_minutes},
                      "warningBeforeTimeout": 5
                    }
                  }'
              EOT
            }
          
            triggers = {
              max_duration = var.session_max_duration_minutes
              idle_timeout = var.session_idle_timeout_minutes
            }
            }
          
            # Enable real-time session monitoring for security team
            resource "null_resource" "psm_live_monitoring" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/PSMSettings" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "enableLiveMonitoring": true,
                      "allowSessionSuspension": true,
                      "allowSessionTermination": true
                    }
                  }'
              EOT
            }
          
            triggers = {
              monitoring = "enabled"
            }
            }
          
            # L2+: Enforce stricter session controls
            resource "null_resource" "psm_strict_session_controls" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/PlatformConfiguration" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "maxSessionDuration": 240,
                      "idleSessionTimeout": 15,
                      "warningBeforeTimeout": 5,
                      "requireReauthOnResume": true,
                      "blockClipboardTransfer": true
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.psm_session_timeouts]
          
            triggers = {
              profile_level = var.profile_level
            }
            }
  cli:
    lang: "ini"
    filename: "hth-cyberark-4.01-session-timeouts.ini"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/cli/hth-cyberark-4.01-session-timeouts.ini"
    excerpts:
      cli-session-timeouts:
        content: |
            # Platform configuration
            MaxSessionDuration=480  # 8 hours maximum
            IdleSessionTimeout=30   # 30 minutes idle
            WarningBeforeTimeout=5  # 5 minute warning

"4.2":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-4.02-just-in-time-access.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-4.02-just-in-time-access.tf"
    excerpts:
      terraform:
        content: |
            # L2+: Configure exclusive access and one-time password via Master Policy
            resource "null_resource" "jit_exclusive_access" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/MasterPolicy" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "policyName": "JustInTimeAccess",
                    "settings": {
                      "exclusiveAccess": true,
                      "oneTimePassword": true,
                      "autoRotateAfterRetrieval": true,
                      "requireDualControlPasswordAccessApproval": true
                    }
                  }'
              EOT
            }
          
            triggers = {
              profile_level = var.profile_level
            }
            }
          
            # L2+: Configure access request workflow
            resource "null_resource" "jit_request_workflow" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/MasterPolicy" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "policyName": "AccessRequestWorkflow",
                    "settings": {
                      "requireBusinessJustification": true,
                      "requireTicketNumber": true,
                      "accessExpirationMinutes": 240,
                      "autoApproveAfterMinutes": 0,
                      "notifyApproversOnRequest": true
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.jit_exclusive_access]
          
            triggers = {
              profile_level = var.profile_level
            }
            }
          
            # L3: Enforce time-boxed access with automatic credential rotation
            resource "null_resource" "jit_time_boxed_access" {
            count = var.profile_level >= 3 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/MasterPolicy" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "policyName": "TimeBoxedAccess",
                    "settings": {
                      "exclusiveAccess": true,
                      "oneTimePassword": true,
                      "autoRotateAfterRetrieval": true,
                      "accessExpirationMinutes": 60,
                      "enforceCheckInCheckOut": true,
                      "requireMultipleApprovers": true,
                      "minApprovers": 2
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.jit_request_workflow]
          
            triggers = {
              profile_level = var.profile_level
            }
            }

"5.1":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-5.01-automatic-password-rotation.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-5.01-automatic-password-rotation.tf"
    excerpts:
      terraform:
        content: |
            # Configure CPM password rotation policy
            resource "null_resource" "cpm_rotation_policy" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/PlatformConfiguration" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "passwordChangeInterval": ${var.password_rotation_days},
                      "verificationIntervalHours": ${var.password_verification_interval_hours},
                      "reconcileIntervalDays": 7
                    }
                  }'
              EOT
            }
          
            triggers = {
              rotation_days         = var.password_rotation_days
              verification_interval = var.password_verification_interval_hours
            }
            }
          
            # Configure password complexity requirements
            resource "null_resource" "password_complexity" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/PasswordPolicy" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "minLength": ${var.password_min_length},
                      "requireUppercase": true,
                      "requireLowercase": true,
                      "requireNumbers": true,
                      "requireSpecial": true,
                      "excludedCharacters": "\"<>;"
                    }
                  }'
              EOT
            }
          
            triggers = {
              min_length = var.password_min_length
            }
            }
          
            # L2+: Enforce aggressive rotation (7-day interval)
            resource "null_resource" "aggressive_rotation" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/PlatformConfiguration" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "passwordChangeInterval": 7,
                      "verificationIntervalHours": 12,
                      "reconcileIntervalDays": 3,
                      "autoRotateOnCheckIn": true
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.cpm_rotation_policy]
          
            triggers = {
              profile_level = var.profile_level
            }
            }
          
            # L3: Enforce one-time-use passwords with immediate rotation
            resource "null_resource" "one_time_passwords" {
            count = var.profile_level >= 3 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/PlatformConfiguration" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "passwordChangeInterval": 1,
                      "oneTimePassword": true,
                      "autoRotateAfterRetrieval": true,
                      "verificationIntervalHours": 6,
                      "reconcileIntervalDays": 1
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.aggressive_rotation]
          
            triggers = {
              profile_level = var.profile_level
            }
            }
  cli:
    lang: "ini"
    filename: "hth-cyberark-5.01-password-complexity.ini"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/cli/hth-cyberark-5.01-password-complexity.ini"
    excerpts:
      cli-password-complexity:
        content: |
            # Platform password policy
            MinLength=20
            RequireUppercase=true
            RequireLowercase=true
            RequireNumbers=true
            RequireSpecial=true
            ExcludedCharacters='"<>;

"5.2":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-5.02-monitor-rotation-failures.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-5.02-monitor-rotation-failures.tf"
    excerpts:
      terraform:
        content: |
            # Check for CPM password rotation failures
            resource "null_resource" "rotation_failure_check" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X GET \
                  "${var.pvwa_url}/PasswordVault/API/Accounts?filter=cpmStatus eq failure" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  | python3 -c "
            import sys, json
            data = json.load(sys.stdin)
            accounts = data.get('value', [])
            failed = [a for a in accounts if a.get('secretManagement', {}).get('status') == 'failure']
            if failed:
              print(f'WARNING: {len(failed)} account(s) with rotation failures:')
              for acct in failed:
                  name = acct.get('name', 'unknown')
                  safe = acct.get('safeName', 'unknown')
                  reason = acct.get('secretManagement', {}).get('lastModifiedReason', 'unknown')
                  print(f'  - {name} in {safe}: {reason}')
              sys.exit(1)
            else:
              print('OK: No rotation failures detected')
            "
              EOT
            }
          
            triggers = {
              check_interval = timestamp()
            }
            }
          
            # Configure alerting for rotation failures
            resource "null_resource" "rotation_failure_alerting" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/Notifications" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "notifyOnCPMFailure": true,
                      "notifyOnVerificationFailure": true,
                      "notifyOnReconcileFailure": true,
                      "failureNotificationRecipients": "security-team"
                    }
                  }'
              EOT
            }
          
            triggers = {
              notification_config = "enabled"
            }
            }
          
            # L2+: Configure automatic reconciliation on rotation failure
            resource "null_resource" "auto_reconcile_on_failure" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/PlatformConfiguration" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "autoReconcileOnFailure": true,
                      "maxReconcileAttempts": 3,
                      "reconcileRetryIntervalMinutes": 30
                    }
                  }'
              EOT
            }
          
            triggers = {
              profile_level = var.profile_level
            }
            }
  db:
    lang: "sql"
    filename: "hth-cyberark-5.02-rotation-failures.sql"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/db/hth-cyberark-5.02-rotation-failures.sql"
    excerpts:
      db-rotation-failures:
        content: |
            -- Query for rotation failures (via SIEM or reporting)
            SELECT AccountName, SafeName, LastFailReason, LastFailDate
            FROM PasswordVault_Accounts
            WHERE CPMStatus = 'FAILED'
            ORDER BY LastFailDate DESC;

"6.1":
  terraform:
    lang: "hcl"
    filename: "hth-cyberark-6.01-comprehensive-audit-logging.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/terraform/hth-cyberark-6.01-comprehensive-audit-logging.tf"
    excerpts:
      terraform:
        content: |
            # Configure comprehensive audit logging
            resource "null_resource" "audit_logging_config" {
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/AuditSettings" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "auditEnabled": true,
                      "logLogonEvents": true,
                      "logRetrieveEvents": true,
                      "logPasswordChangeEvents": true,
                      "logSafeModificationEvents": true,
                      "logPolicyChanges": true,
                      "retentionDays": ${var.audit_retention_days}
                    }
                  }'
              EOT
            }
          
            triggers = {
              retention_days = var.audit_retention_days
            }
            }
          
            # Configure SIEM log forwarding
            resource "null_resource" "siem_log_forwarding" {
            count = var.siem_server != "" ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/SyslogSettings" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "syslogEnabled": true,
                      "syslogServer": "${var.siem_server}",
                      "syslogPort": ${var.siem_port},
                      "syslogProtocol": "TCP",
                      "syslogFormat": "CEF",
                      "sendRealtimeEvents": true
                    }
                  }'
              EOT
            }
          
            triggers = {
              siem_server = var.siem_server
              siem_port   = var.siem_port
            }
            }
          
            # L2+: Enable enhanced detection use cases
            resource "null_resource" "enhanced_detection" {
            count = var.profile_level >= 2 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/AuditSettings" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "detectMassRetrieval": true,
                      "massRetrievalThreshold": 20,
                      "massRetrievalWindowMinutes": 60,
                      "detectAfterHoursAccess": true,
                      "businessHoursStart": 6,
                      "businessHoursEnd": 20,
                      "detectFailedAuthSpike": true,
                      "failedAuthThreshold": 5,
                      "failedAuthWindowMinutes": 15,
                      "alertOnDetection": true
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.audit_logging_config]
          
            triggers = {
              profile_level = var.profile_level
            }
            }
          
            # L3: Enable full forensic logging with immutable audit trail
            resource "null_resource" "forensic_logging" {
            count = var.profile_level >= 3 ? 1 : 0
          
            provisioner "local-exec" {
              command = <<-EOT
                curl -sk -X PUT \
                  "${var.pvwa_url}/PasswordVault/API/Configuration/AuditSettings" \
                  -H "Authorization: ${var.pvwa_auth_token}" \
                  -H "Content-Type: application/json" \
                  -d '{
                    "settings": {
                      "immutableAuditTrail": true,
                      "logAllAPIRequests": true,
                      "logSessionKeystrokes": true,
                      "logClipboardEvents": true,
                      "retentionDays": 730,
                      "tamperDetection": true,
                      "hashVerification": true
                    }
                  }'
              EOT
            }
          
            depends_on = [null_resource.enhanced_detection]
          
            triggers = {
              profile_level = var.profile_level
            }
            }
  db:
    lang: "sql"
    filename: "hth-cyberark-6.01-audit-detection-queries.sql"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cyberark/db/hth-cyberark-6.01-audit-detection-queries.sql"
    excerpts:
      db-mass-retrieval:
        content: |
            SELECT UserName, COUNT(*) as RetrievalCount
            FROM AuditLog
            WHERE Action = 'Retrieve Password'
            AND Timestamp > DATEADD(hour, -1, GETDATE())
            GROUP BY UserName
            HAVING COUNT(*) > 20;
      db-after-hours-access:
        content: |
            SELECT *
            FROM AuditLog
            WHERE Action IN ('Logon', 'Retrieve Password')
            AND (DATEPART(hour, Timestamp) < 6 OR DATEPART(hour, Timestamp) > 20)
            AND DATEPART(dw, Timestamp) IN (1, 7);  -- Weekends
      db-failed-auth-spike:
        content: |
            SELECT UserName, SourceIP, COUNT(*) as FailedAttempts
            FROM AuditLog
            WHERE Action = 'Logon'
            AND Status = 'Failed'
            AND Timestamp > DATEADD(minute, -15, GETDATE())
            GROUP BY UserName, SourceIP
            HAVING COUNT(*) > 5;

