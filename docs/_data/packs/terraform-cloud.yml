# AUTO-GENERATED by scripts/sync-packs-to-data.sh â€” do not edit manually
# Generated: 2026-02-18T20:49:08Z
# Generated: 2026-02-18T20:49:08Z


"1.2":
"1.2":
  terraform:
  terraform:
    lang: "hcl"
    lang: "hcl"
    filename: "hth-terraform-cloud-1.02-team-based-access-control.tf"
    filename: "hth-terraform-cloud-1.02-team-based-access-control.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/terraform/hth-terraform-cloud-1.02-team-based-access-control.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/terraform/hth-terraform-cloud-1.02-team-based-access-control.tf"
    excerpts:
    excerpts:
      terraform:
      terraform:
        content: |
        content: |
            # --- Team definitions ---
            # Owners team is managed by Terraform Cloud automatically; do not recreate it.
          
            resource "tfe_team" "platform" {
            name         = "platform"
            organization = var.tfc_organization
          
            organization_access {
              manage_workspaces = true
              manage_policies   = false
              manage_providers  = true
              manage_modules    = true
              manage_vcs_settings = false
            }
            }
          
            resource "tfe_team" "developers" {
            name         = "developers"
            organization = var.tfc_organization
          
            organization_access {
              manage_workspaces   = false
              manage_policies     = false
              manage_providers    = false
              manage_modules      = false
              manage_vcs_settings = false
            }
            }
          
            resource "tfe_team" "readonly" {
            name         = "read-only"
            organization = var.tfc_organization
          
            organization_access {
              manage_workspaces   = false
              manage_policies     = false
              manage_providers    = false
              manage_modules      = false
              manage_vcs_settings = false
            }
            }
          
            # --- Workspace-level access grants ---
            # Platform team: admin on all workspaces
            resource "tfe_team_access" "platform" {
            for_each     = var.workspace_ids
            team_id      = tfe_team.platform.id
            workspace_id = each.value
            access       = "admin"
            }
          
            # Developers: plan-only on all workspaces (no apply)
            resource "tfe_team_access" "developers" {
            for_each     = var.workspace_ids
            team_id      = tfe_team.developers.id
            workspace_id = each.value
            access       = "plan"
            }
          
            # Read-only: read on all workspaces
            resource "tfe_team_access" "readonly" {
            for_each     = var.workspace_ids
            team_id      = tfe_team.readonly.id
            workspace_id = each.value
            access       = "read"
            }
            # --- Team definitions ---
            # Owners team is managed by Terraform Cloud automatically; do not recreate it.
          
            resource "tfe_team" "platform" {
            name         = "platform"
            organization = var.tfc_organization
          
            organization_access {
              manage_workspaces = true
              manage_policies   = false
              manage_providers  = true
              manage_modules    = true
              manage_vcs_settings = false
            }
            }
          
            resource "tfe_team" "developers" {
            name         = "developers"
            organization = var.tfc_organization
          
            organization_access {
              manage_workspaces   = false
              manage_policies     = false
              manage_providers    = false
              manage_modules      = false
              manage_vcs_settings = false
            }
            }
          
            resource "tfe_team" "readonly" {
            name         = "read-only"
            organization = var.tfc_organization
          
            organization_access {
              manage_workspaces   = false
              manage_policies     = false
              manage_providers    = false
              manage_modules      = false
              manage_vcs_settings = false
            }
            }
          
            # --- Workspace-level access grants ---
            # Platform team: admin on all workspaces
            resource "tfe_team_access" "platform" {
            for_each     = var.workspace_ids
            team_id      = tfe_team.platform.id
            workspace_id = each.value
            access       = "admin"
            }
          
            # Developers: plan-only on all workspaces (no apply)
            resource "tfe_team_access" "developers" {
            for_each     = var.workspace_ids
            team_id      = tfe_team.developers.id
            workspace_id = each.value
            access       = "plan"
            }
          
            # Read-only: read on all workspaces
            resource "tfe_team_access" "readonly" {
            for_each     = var.workspace_ids
            team_id      = tfe_team.readonly.id
            workspace_id = each.value
            access       = "read"
            }
  api:
  api:
    lang: "bash"
    lang: "bash"
    filename: "hth-terraform-cloud-1.02-team-based-access-control.sh"
    filename: "hth-terraform-cloud-1.02-team-based-access-control.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/api/hth-terraform-cloud-1.02-team-based-access-control.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/api/hth-terraform-cloud-1.02-team-based-access-control.sh"
    excerpts:
    excerpts:
      api-audit-teams:
      api-audit-teams:
        content: |
        content: |
            # Fetch all teams in the organization
            TEAMS_RESPONSE=$(tfc_get "/organizations/${TFC_ORG}/teams") || {
            fail "1.02 Unable to retrieve teams for org ${TFC_ORG}"
            increment_failed
            summary
            exit 0
            }
          
            TEAM_COUNT=$(echo "${TEAMS_RESPONSE}" | jq '.data | length')
            info "1.02 Found ${TEAM_COUNT} team(s) in organization ${TFC_ORG}"
          
            # Audit each team's permissions
            echo "${TEAMS_RESPONSE}" | jq -r '.data[] | @base64' | while read -r TEAM_B64; do
            TEAM_JSON=$(echo "${TEAM_B64}" | base64 -d)
            TEAM_NAME=$(echo "${TEAM_JSON}" | jq -r '.attributes.name')
            TEAM_ID=$(echo "${TEAM_JSON}" | jq -r '.id')
            MANAGE_WORKSPACES=$(echo "${TEAM_JSON}" | jq -r '.attributes."organization-access"."manage-workspaces" // false')
            MANAGE_POLICIES=$(echo "${TEAM_JSON}" | jq -r '.attributes."organization-access"."manage-policies" // false')
            MANAGE_VCS=$(echo "${TEAM_JSON}" | jq -r '.attributes."organization-access"."manage-vcs-settings" // false')
          
            info "1.02 Team: ${TEAM_NAME} (ID: ${TEAM_ID})"
          
            # Flag overly permissive teams
            if [ "${MANAGE_WORKSPACES}" = "true" ] && [ "${MANAGE_POLICIES}" = "true" ] && [ "${MANAGE_VCS}" = "true" ]; then
              warn "1.02   ${TEAM_NAME} has full org-level access -- review for least privilege"
            fi
          
            # Check team membership count
            MEMBERS_RESPONSE=$(tfc_get "/teams/${TEAM_ID}/memberships") || {
              warn "1.02   Unable to retrieve members for team ${TEAM_NAME}"
              continue
            }
            MEMBER_COUNT=$(echo "${MEMBERS_RESPONSE}" | jq '.data | length')
            info "1.02   Members: ${MEMBER_COUNT}"
          
            # Flag empty teams
            if [ "${MEMBER_COUNT}" = "0" ]; then
              warn "1.02   ${TEAM_NAME} has no members -- consider removing"
            fi
          
            # Check workspace-level access grants
            ACCESS_RESPONSE=$(tfc_get "/teams/${TEAM_ID}/team-workspaces") || {
              warn "1.02   Unable to retrieve workspace access for team ${TEAM_NAME}"
              continue
            }
            WORKSPACE_COUNT=$(echo "${ACCESS_RESPONSE}" | jq '.data | length')
            info "1.02   Workspace grants: ${WORKSPACE_COUNT}"
          
            # Flag admin access on many workspaces
            ADMIN_COUNT=$(echo "${ACCESS_RESPONSE}" | jq '[.data[] | select(.attributes.access == "admin")] | length')
            if [ "${ADMIN_COUNT}" -gt 5 ]; then
              warn "1.02   ${TEAM_NAME} has admin access on ${ADMIN_COUNT} workspaces -- review for least privilege"
            fi
            done
          
            pass "1.02 Team access audit complete"
            increment_applied
            # Fetch all teams in the organization
            TEAMS_RESPONSE=$(tfc_get "/organizations/${TFC_ORG}/teams") || {
            fail "1.02 Unable to retrieve teams for org ${TFC_ORG}"
            increment_failed
            summary
            exit 0
            }
          
            TEAM_COUNT=$(echo "${TEAMS_RESPONSE}" | jq '.data | length')
            info "1.02 Found ${TEAM_COUNT} team(s) in organization ${TFC_ORG}"
          
            # Audit each team's permissions
            echo "${TEAMS_RESPONSE}" | jq -r '.data[] | @base64' | while read -r TEAM_B64; do
            TEAM_JSON=$(echo "${TEAM_B64}" | base64 -d)
            TEAM_NAME=$(echo "${TEAM_JSON}" | jq -r '.attributes.name')
            TEAM_ID=$(echo "${TEAM_JSON}" | jq -r '.id')
            MANAGE_WORKSPACES=$(echo "${TEAM_JSON}" | jq -r '.attributes."organization-access"."manage-workspaces" // false')
            MANAGE_POLICIES=$(echo "${TEAM_JSON}" | jq -r '.attributes."organization-access"."manage-policies" // false')
            MANAGE_VCS=$(echo "${TEAM_JSON}" | jq -r '.attributes."organization-access"."manage-vcs-settings" // false')
          
            info "1.02 Team: ${TEAM_NAME} (ID: ${TEAM_ID})"
          
            # Flag overly permissive teams
            if [ "${MANAGE_WORKSPACES}" = "true" ] && [ "${MANAGE_POLICIES}" = "true" ] && [ "${MANAGE_VCS}" = "true" ]; then
              warn "1.02   ${TEAM_NAME} has full org-level access -- review for least privilege"
            fi
          
            # Check team membership count
            MEMBERS_RESPONSE=$(tfc_get "/teams/${TEAM_ID}/memberships") || {
              warn "1.02   Unable to retrieve members for team ${TEAM_NAME}"
              continue
            }
            MEMBER_COUNT=$(echo "${MEMBERS_RESPONSE}" | jq '.data | length')
            info "1.02   Members: ${MEMBER_COUNT}"
          
            # Flag empty teams
            if [ "${MEMBER_COUNT}" = "0" ]; then
              warn "1.02   ${TEAM_NAME} has no members -- consider removing"
            fi
          
            # Check workspace-level access grants
            ACCESS_RESPONSE=$(tfc_get "/teams/${TEAM_ID}/team-workspaces") || {
              warn "1.02   Unable to retrieve workspace access for team ${TEAM_NAME}"
              continue
            }
            WORKSPACE_COUNT=$(echo "${ACCESS_RESPONSE}" | jq '.data | length')
            info "1.02   Workspace grants: ${WORKSPACE_COUNT}"
          
            # Flag admin access on many workspaces
            ADMIN_COUNT=$(echo "${ACCESS_RESPONSE}" | jq '[.data[] | select(.attributes.access == "admin")] | length')
            if [ "${ADMIN_COUNT}" -gt 5 ]; then
              warn "1.02   ${TEAM_NAME} has admin access on ${ADMIN_COUNT} workspaces -- review for least privilege"
            fi
            done
          
            pass "1.02 Team access audit complete"
            increment_applied


"2.1":
"2.1":
  terraform:
  terraform:
    lang: "hcl"
    lang: "hcl"
    filename: "hth-terraform-cloud-2.01-configure-workspace-restrictions.tf"
    filename: "hth-terraform-cloud-2.01-configure-workspace-restrictions.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/terraform/hth-terraform-cloud-2.01-configure-workspace-restrictions.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/terraform/hth-terraform-cloud-2.01-configure-workspace-restrictions.tf"
    excerpts:
    excerpts:
      terraform:
      terraform:
        content: |
        content: |
            resource "tfe_workspace" "hardened" {
            name                  = var.workspace_name
            organization          = var.tfc_organization
            execution_mode        = "remote"
            auto_apply            = false
            speculative_enabled   = true
            file_triggers_enabled = true
            queue_all_runs        = false
            assessments_enabled   = true
          
            # Require VCS-driven runs only -- block CLI/API applies in production
            dynamic "vcs_repo" {
              for_each = var.vcs_repo_identifier != "" ? [1] : []
              content {
                identifier     = var.vcs_repo_identifier
                oauth_token_id = var.vcs_oauth_token_id
                branch         = "main"
              }
            }
            }
            resource "tfe_workspace" "hardened" {
            name                  = var.workspace_name
            organization          = var.tfc_organization
            execution_mode        = "remote"
            auto_apply            = false
            speculative_enabled   = true
            file_triggers_enabled = true
            queue_all_runs        = false
            assessments_enabled   = true
          
            # Require VCS-driven runs only -- block CLI/API applies in production
            dynamic "vcs_repo" {
              for_each = var.vcs_repo_identifier != "" ? [1] : []
              content {
                identifier     = var.vcs_repo_identifier
                oauth_token_id = var.vcs_oauth_token_id
                branch         = "main"
              }
            }
            }
  api:
  api:
    lang: "bash"
    lang: "bash"
    filename: "hth-terraform-cloud-2.01-configure-workspace-restrictions.sh"
    filename: "hth-terraform-cloud-2.01-configure-workspace-restrictions.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/api/hth-terraform-cloud-2.01-configure-workspace-restrictions.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/api/hth-terraform-cloud-2.01-configure-workspace-restrictions.sh"
    excerpts:
    excerpts:
      api-audit-workspaces:
      api-audit-workspaces:
        content: |
        content: |
            # Fetch all workspaces in the organization
            PAGE=1
            TOTAL_WORKSPACES=0
            AUTO_APPLY_VIOLATIONS=0
            EXEC_MODE_VIOLATIONS=0
          
            while true; do
            WS_RESPONSE=$(tfc_get "/organizations/${TFC_ORG}/workspaces?page%5Bnumber%5D=${PAGE}&page%5Bsize%5D=20") || {
              fail "2.01 Unable to retrieve workspaces for org ${TFC_ORG} (page ${PAGE})"
              increment_failed
              summary
              exit 0
            }
          
            WS_COUNT=$(echo "${WS_RESPONSE}" | jq '.data | length')
            if [ "${WS_COUNT}" = "0" ]; then
              break
            fi
          
            echo "${WS_RESPONSE}" | jq -r '.data[] | @base64' | while read -r WS_B64; do
              WS_JSON=$(echo "${WS_B64}" | base64 -d)
              WS_NAME=$(echo "${WS_JSON}" | jq -r '.attributes.name')
              AUTO_APPLY=$(echo "${WS_JSON}" | jq -r '.attributes."auto-apply" // false')
              EXEC_MODE=$(echo "${WS_JSON}" | jq -r '.attributes."execution-mode" // "remote"')
              SPECULATIVE=$(echo "${WS_JSON}" | jq -r '.attributes."speculative-enabled" // false')
          
              # Check auto-apply -- should be disabled for production workspaces
              if [ "${AUTO_APPLY}" = "true" ]; then
                fail "2.01 ${WS_NAME}: auto-apply is ENABLED -- disable for production workspaces"
                AUTO_APPLY_VIOLATIONS=$((AUTO_APPLY_VIOLATIONS + 1))
              else
                pass "2.01 ${WS_NAME}: auto-apply is disabled"
              fi
          
              # Check execution mode -- should be remote
              if [ "${EXEC_MODE}" != "remote" ]; then
                warn "2.01 ${WS_NAME}: execution mode is '${EXEC_MODE}' (expected 'remote')"
                EXEC_MODE_VIOLATIONS=$((EXEC_MODE_VIOLATIONS + 1))
              else
                pass "2.01 ${WS_NAME}: execution mode is remote"
              fi
          
              # Check speculative plans
              if [ "${SPECULATIVE}" != "true" ]; then
                warn "2.01 ${WS_NAME}: speculative plans are disabled -- enable for PR previews"
              fi
          
              TOTAL_WORKSPACES=$((TOTAL_WORKSPACES + 1))
            done
          
            # Check for next page
            NEXT_PAGE=$(echo "${WS_RESPONSE}" | jq -r '.meta.pagination."next-page" // empty')
            if [ -z "${NEXT_PAGE}" ]; then
              break
            fi
            PAGE=$((PAGE + 1))
            done
          
            info "2.01 Audited ${TOTAL_WORKSPACES} workspace(s)"
          
            if [ "${AUTO_APPLY_VIOLATIONS}" -gt 0 ] || [ "${EXEC_MODE_VIOLATIONS}" -gt 0 ]; then
            fail "2.01 Found ${AUTO_APPLY_VIOLATIONS} auto-apply and ${EXEC_MODE_VIOLATIONS} execution mode violation(s)"
            increment_failed
            else
            pass "2.01 All workspaces meet hardening requirements"
            increment_applied
            fi
            # Fetch all workspaces in the organization
            PAGE=1
            TOTAL_WORKSPACES=0
            AUTO_APPLY_VIOLATIONS=0
            EXEC_MODE_VIOLATIONS=0
          
            while true; do
            WS_RESPONSE=$(tfc_get "/organizations/${TFC_ORG}/workspaces?page%5Bnumber%5D=${PAGE}&page%5Bsize%5D=20") || {
              fail "2.01 Unable to retrieve workspaces for org ${TFC_ORG} (page ${PAGE})"
              increment_failed
              summary
              exit 0
            }
          
            WS_COUNT=$(echo "${WS_RESPONSE}" | jq '.data | length')
            if [ "${WS_COUNT}" = "0" ]; then
              break
            fi
          
            echo "${WS_RESPONSE}" | jq -r '.data[] | @base64' | while read -r WS_B64; do
              WS_JSON=$(echo "${WS_B64}" | base64 -d)
              WS_NAME=$(echo "${WS_JSON}" | jq -r '.attributes.name')
              AUTO_APPLY=$(echo "${WS_JSON}" | jq -r '.attributes."auto-apply" // false')
              EXEC_MODE=$(echo "${WS_JSON}" | jq -r '.attributes."execution-mode" // "remote"')
              SPECULATIVE=$(echo "${WS_JSON}" | jq -r '.attributes."speculative-enabled" // false')
          
              # Check auto-apply -- should be disabled for production workspaces
              if [ "${AUTO_APPLY}" = "true" ]; then
                fail "2.01 ${WS_NAME}: auto-apply is ENABLED -- disable for production workspaces"
                AUTO_APPLY_VIOLATIONS=$((AUTO_APPLY_VIOLATIONS + 1))
              else
                pass "2.01 ${WS_NAME}: auto-apply is disabled"
              fi
          
              # Check execution mode -- should be remote
              if [ "${EXEC_MODE}" != "remote" ]; then
                warn "2.01 ${WS_NAME}: execution mode is '${EXEC_MODE}' (expected 'remote')"
                EXEC_MODE_VIOLATIONS=$((EXEC_MODE_VIOLATIONS + 1))
              else
                pass "2.01 ${WS_NAME}: execution mode is remote"
              fi
          
              # Check speculative plans
              if [ "${SPECULATIVE}" != "true" ]; then
                warn "2.01 ${WS_NAME}: speculative plans are disabled -- enable for PR previews"
              fi
          
              TOTAL_WORKSPACES=$((TOTAL_WORKSPACES + 1))
            done
          
            # Check for next page
            NEXT_PAGE=$(echo "${WS_RESPONSE}" | jq -r '.meta.pagination."next-page" // empty')
            if [ -z "${NEXT_PAGE}" ]; then
              break
            fi
            PAGE=$((PAGE + 1))
            done
          
            info "2.01 Audited ${TOTAL_WORKSPACES} workspace(s)"
          
            if [ "${AUTO_APPLY_VIOLATIONS}" -gt 0 ] || [ "${EXEC_MODE_VIOLATIONS}" -gt 0 ]; then
            fail "2.01 Found ${AUTO_APPLY_VIOLATIONS} auto-apply and ${EXEC_MODE_VIOLATIONS} execution mode violation(s)"
            increment_failed
            else
            pass "2.01 All workspaces meet hardening requirements"
            increment_applied
            fi
  sigma:
  sigma:
    - lang: "yaml"
    - lang: "yaml"
      filename: "hth-terraform-cloud-2.01-configure-workspace-restrictions.yml"
      filename: "hth-terraform-cloud-2.01-configure-workspace-restrictions.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/siem/sigma/hth-terraform-cloud-2.01-configure-workspace-restrictions.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/siem/sigma/hth-terraform-cloud-2.01-configure-workspace-restrictions.yml"
      excerpts:
      excerpts:
        detection:
        detection:
          content: |
          content: |
              detection:
                selection:
                    resource_type: 'workspace'
                    action: 'update'
                filter_auto_apply:
                    new_values|contains: '"auto-apply":true'
                condition: selection and filter_auto_apply
              fields:
                - actor
                - action
                - resource_type
                - resource_id
                - timestamp
              detection:
                selection:
                    resource_type: 'workspace'
                    action: 'update'
                filter_auto_apply:
                    new_values|contains: '"auto-apply":true'
                condition: selection and filter_auto_apply
              fields:
                - actor
                - action
                - resource_type
                - resource_id
                - timestamp


"2.2":
"2.2":
  terraform:
  terraform:
    lang: "hcl"
    lang: "hcl"
    filename: "hth-terraform-cloud-2.02-sentinel-policy-enforcement.tf"
    filename: "hth-terraform-cloud-2.02-sentinel-policy-enforcement.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/terraform/hth-terraform-cloud-2.02-sentinel-policy-enforcement.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/terraform/hth-terraform-cloud-2.02-sentinel-policy-enforcement.tf"
    excerpts:
    excerpts:
      terraform:
      terraform:
        content: |
        content: |
            # Sentinel policy: require encryption on S3 buckets
            resource "tfe_sentinel_policy" "require_encryption" {
            name         = "require-s3-encryption"
            description  = "Require server-side encryption on all S3 buckets"
            organization = var.tfc_organization
            policy       = <<-SENTINEL
              import "tfplan/v2" as tfplan
          
              s3_buckets = filter tfplan.resource_changes as _, rc {
                rc.type is "aws_s3_bucket" and
                (rc.change.actions contains "create" or rc.change.actions contains "update")
              }
          
              encryption_enabled = rule {
                all s3_buckets as _, bucket {
                  bucket.change.after.server_side_encryption_configuration is not null
                }
              }
          
              main = rule {
                encryption_enabled
              }
            SENTINEL
            enforce_mode = "hard-mandatory"
            }
          
            # Sentinel policy: deny public access
            resource "tfe_sentinel_policy" "deny_public_access" {
            name         = "deny-public-access"
            description  = "Deny public access blocks being disabled on S3 buckets"
            organization = var.tfc_organization
            policy       = <<-SENTINEL
              import "tfplan/v2" as tfplan
          
              s3_public_access = filter tfplan.resource_changes as _, rc {
                rc.type is "aws_s3_bucket_public_access_block" and
                (rc.change.actions contains "create" or rc.change.actions contains "update")
              }
          
              all_blocked = rule {
                all s3_public_access as _, block {
                  block.change.after.block_public_acls is true and
                  block.change.after.block_public_policy is true and
                  block.change.after.ignore_public_acls is true and
                  block.change.after.restrict_public_buckets is true
                }
              }
          
              main = rule {
                all_blocked
              }
            SENTINEL
            enforce_mode = "hard-mandatory"
            }
          
            # Policy set: attach policies to workspaces via VCS or inline
            resource "tfe_policy_set" "security_guardrails" {
            name          = "hth-security-guardrails"
            description   = "HTH security guardrails -- hard-mandatory enforcement"
            organization  = var.tfc_organization
            kind          = "sentinel"
            workspace_ids = var.workspace_ids
          
            # VCS-backed policy set (recommended for versioned policies)
            dynamic "vcs_repo" {
              for_each = var.sentinel_vcs_identifier != "" ? [1] : []
              content {
                identifier     = var.sentinel_vcs_identifier
                oauth_token_id = var.sentinel_oauth_token_id
                branch         = "main"
              }
            }
            }
          
            # Attach individual policies to the policy set
            resource "tfe_policy_set_parameter" "encryption_policy" {
            policy_set_id = tfe_policy_set.security_guardrails.id
            key           = "require_encryption"
            value         = "true"
            category      = "sentinel"
            }
            # Sentinel policy: require encryption on S3 buckets
            resource "tfe_sentinel_policy" "require_encryption" {
            name         = "require-s3-encryption"
            description  = "Require server-side encryption on all S3 buckets"
            organization = var.tfc_organization
            policy       = <<-SENTINEL
              import "tfplan/v2" as tfplan
          
              s3_buckets = filter tfplan.resource_changes as _, rc {
                rc.type is "aws_s3_bucket" and
                (rc.change.actions contains "create" or rc.change.actions contains "update")
              }
          
              encryption_enabled = rule {
                all s3_buckets as _, bucket {
                  bucket.change.after.server_side_encryption_configuration is not null
                }
              }
          
              main = rule {
                encryption_enabled
              }
            SENTINEL
            enforce_mode = "hard-mandatory"
            }
          
            # Sentinel policy: deny public access
            resource "tfe_sentinel_policy" "deny_public_access" {
            name         = "deny-public-access"
            description  = "Deny public access blocks being disabled on S3 buckets"
            organization = var.tfc_organization
            policy       = <<-SENTINEL
              import "tfplan/v2" as tfplan
          
              s3_public_access = filter tfplan.resource_changes as _, rc {
                rc.type is "aws_s3_bucket_public_access_block" and
                (rc.change.actions contains "create" or rc.change.actions contains "update")
              }
          
              all_blocked = rule {
                all s3_public_access as _, block {
                  block.change.after.block_public_acls is true and
                  block.change.after.block_public_policy is true and
                  block.change.after.ignore_public_acls is true and
                  block.change.after.restrict_public_buckets is true
                }
              }
          
              main = rule {
                all_blocked
              }
            SENTINEL
            enforce_mode = "hard-mandatory"
            }
          
            # Policy set: attach policies to workspaces via VCS or inline
            resource "tfe_policy_set" "security_guardrails" {
            name          = "hth-security-guardrails"
            description   = "HTH security guardrails -- hard-mandatory enforcement"
            organization  = var.tfc_organization
            kind          = "sentinel"
            workspace_ids = var.workspace_ids
          
            # VCS-backed policy set (recommended for versioned policies)
            dynamic "vcs_repo" {
              for_each = var.sentinel_vcs_identifier != "" ? [1] : []
              content {
                identifier     = var.sentinel_vcs_identifier
                oauth_token_id = var.sentinel_oauth_token_id
                branch         = "main"
              }
            }
            }
          
            # Attach individual policies to the policy set
            resource "tfe_policy_set_parameter" "encryption_policy" {
            policy_set_id = tfe_policy_set.security_guardrails.id
            key           = "require_encryption"
            value         = "true"
            category      = "sentinel"
            }


"5.1":
"5.1":
  terraform:
  terraform:
    lang: "hcl"
    lang: "hcl"
    filename: "hth-terraform-cloud-5.01-audit-logging.tf"
    filename: "hth-terraform-cloud-5.01-audit-logging.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/terraform/hth-terraform-cloud-5.01-audit-logging.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/terraform/hth-terraform-cloud-5.01-audit-logging.tf"
    excerpts:
    excerpts:
      terraform:
      terraform:
        content: |
        content: |
            # Organization-level settings with audit trail URL
            # Audit logs are available at:
            #   https://app.terraform.io/api/v2/organization/audit-trail
            # Enterprise customers can configure streaming to external SIEM.
            resource "tfe_organization" "main" {
            name  = var.tfc_organization
            email = var.tfc_email
          
            # Require 2FA for all organization members
            collaborator_auth_policy = "two_factor_mandatory"
            }
          
            # Audit trail data source -- verify logging is accessible
            data "http" "audit_trail_check" {
            url = "https://app.terraform.io/api/v2/organization/audit-trail?since=${formatdate("YYYY-MM-DD", timeadd(timestamp(), "-24h"))}"
          
            request_headers = {
              Authorization = "Bearer ${var.tfc_token}"
              Content-Type  = "application/vnd.api+json"
            }
            }
          
            variable "tfc_token" {
            description = "Terraform Cloud API token for audit trail verification"
            type        = string
            sensitive   = true
            }
          
            output "audit_trail_status" {
            description = "HTTP status of audit trail endpoint"
            value       = data.http.audit_trail_check.status_code
            }
            # Organization-level settings with audit trail URL
            # Audit logs are available at:
            #   https://app.terraform.io/api/v2/organization/audit-trail
            # Enterprise customers can configure streaming to external SIEM.
            resource "tfe_organization" "main" {
            name  = var.tfc_organization
            email = var.tfc_email
          
            # Require 2FA for all organization members
            collaborator_auth_policy = "two_factor_mandatory"
            }
          
            # Audit trail data source -- verify logging is accessible
            data "http" "audit_trail_check" {
            url = "https://app.terraform.io/api/v2/organization/audit-trail?since=${formatdate("YYYY-MM-DD", timeadd(timestamp(), "-24h"))}"
          
            request_headers = {
              Authorization = "Bearer ${var.tfc_token}"
              Content-Type  = "application/vnd.api+json"
            }
            }
          
            variable "tfc_token" {
            description = "Terraform Cloud API token for audit trail verification"
            type        = string
            sensitive   = true
            }
          
            output "audit_trail_status" {
            description = "HTTP status of audit trail endpoint"
            value       = data.http.audit_trail_check.status_code
            }
  sigma:
  sigma:
    - lang: "yaml"
    - lang: "yaml"
      filename: "hth-terraform-cloud-5.01-audit-logging.yml"
      filename: "hth-terraform-cloud-5.01-audit-logging.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/siem/sigma/hth-terraform-cloud-5.01-audit-logging.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/terraform-cloud/siem/sigma/hth-terraform-cloud-5.01-audit-logging.yml"
      excerpts:
      excerpts:
        detection:
        detection:
          content: |
          content: |
              detection:
                selection:
                    resource_type: 'audit-trail-destination'
                    action: 'delete'
                condition: selection
              fields:
                - actor
                - action
                - resource_type
                - resource_id
                - timestamp
              detection:
                selection:
                    resource_type: 'audit-trail-destination'
                    action: 'delete'
                condition: selection
              fields:
                - actor
                - action
                - resource_type
                - resource_id
                - timestamp


