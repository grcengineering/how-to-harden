# AUTO-GENERATED by scripts/sync-packs-to-data.sh â€” do not edit manually
# Generated: 2026-02-19T00:06:23Z

"1.3":
  api:
    lang: "bash"
    filename: "hth-gitlab-1.03-configure-personal-access-token-policies.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/api/hth-gitlab-1.03-configure-personal-access-token-policies.sh"
    excerpts:
      api-audit-pat-policies:
        content: |
            # List all active personal access tokens and flag risky configurations
            info "1.3 Retrieving active personal access tokens..."
            PAGE=1
            ALL_PATS="[]"
            while true; do
            RESPONSE=$(gl_get "/personal_access_tokens?state=active&per_page=100&page=${PAGE}" 2>/dev/null) || break
            COUNT=$(echo "${RESPONSE}" | jq 'length' 2>/dev/null || echo "0")
            [ "${COUNT}" -eq 0 ] && break
            ALL_PATS=$(echo "${ALL_PATS} ${RESPONSE}" | jq -s 'add')
            PAGE=$((PAGE + 1))
            done
          
            TOTAL=$(echo "${ALL_PATS}" | jq 'length' 2>/dev/null || echo "0")
            info "1.3 Found ${TOTAL} active personal access token(s)"
          
            # Flag tokens with overly broad 'api' scope
            API_SCOPE_PATS=$(echo "${ALL_PATS}" | jq '[.[] | select(.scopes | index("api"))]' 2>/dev/null || echo "[]")
            API_SCOPE_COUNT=$(echo "${API_SCOPE_PATS}" | jq 'length' 2>/dev/null || echo "0")
          
            if [ "${API_SCOPE_COUNT}" -gt 0 ]; then
            warn "1.3 Found ${API_SCOPE_COUNT} token(s) with full 'api' scope (overly permissive)"
            echo "${API_SCOPE_PATS}" | jq -r '.[] | "  - \(.name // "unnamed") (user: \(.user_id // "unknown"), created: \(.created_at // "unknown"))"' 2>/dev/null || true
            fi
          
            # Flag tokens with no expiration date
            NO_EXPIRY_PATS=$(echo "${ALL_PATS}" | jq '[.[] | select(.expires_at == null)]' 2>/dev/null || echo "[]")
            NO_EXPIRY_COUNT=$(echo "${NO_EXPIRY_PATS}" | jq 'length' 2>/dev/null || echo "0")
          
            if [ "${NO_EXPIRY_COUNT}" -gt 0 ]; then
            warn "1.3 Found ${NO_EXPIRY_COUNT} token(s) with no expiration date"
            echo "${NO_EXPIRY_PATS}" | jq -r '.[] | "  - \(.name // "unnamed") (user: \(.user_id // "unknown"), scopes: \(.scopes | join(", ")))"' 2>/dev/null || true
            fi
          
            # Flag tokens with write_repository scope (supply chain risk)
            WRITE_REPO_PATS=$(echo "${ALL_PATS}" | jq '[.[] | select(.scopes | index("write_repository"))]' 2>/dev/null || echo "[]")
            WRITE_REPO_COUNT=$(echo "${WRITE_REPO_PATS}" | jq 'length' 2>/dev/null || echo "0")
          
            if [ "${WRITE_REPO_COUNT}" -gt 0 ]; then
            warn "1.3 Found ${WRITE_REPO_COUNT} token(s) with 'write_repository' scope"
            echo "${WRITE_REPO_PATS}" | jq -r '.[] | "  - \(.name // "unnamed") (user: \(.user_id // "unknown"), expires: \(.expires_at // "never"))"' 2>/dev/null || true
            fi
  sigma:
    - lang: "yaml"
      filename: "hth-gitlab-1.03-configure-personal-access-token-policies.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/siem/sigma/hth-gitlab-1.03-configure-personal-access-token-policies.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    entity_type: 'PersonalAccessToken'
                    action: 'create'
                condition: selection
              fields:
                - author_name
                - entity_path
                - target_details
                - ip_address
                - created_at

"2.1":
  api:
    lang: "bash"
    filename: "hth-gitlab-2.01-protect-cicd-variables.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/api/hth-gitlab-2.01-protect-cicd-variables.sh"
    excerpts:
      api-audit-cicd-variables:
        content: |
            # Retrieve all project-level CI/CD variables and check protection settings
            VARIABLES=$(gl_get "/projects/${PROJECT_ID}/variables" 2>/dev/null) || {
            fail "2.1 Failed to retrieve CI/CD variables -- check PROJECT_ID and token permissions"
            increment_failed
            summary
            exit 0
            }
          
            VAR_COUNT=$(echo "${VARIABLES}" | jq 'length' 2>/dev/null || echo "0")
            info "2.1 Found ${VAR_COUNT} CI/CD variable(s)"
          
            UNPROTECTED=0
            UNMASKED=0
            RAW_EXPOSED=0
          
            echo "${VARIABLES}" | jq -c '.[]' 2>/dev/null | while IFS= read -r var; do
            KEY=$(echo "${var}" | jq -r '.key')
            PROTECTED=$(echo "${var}" | jq -r '.protected')
            MASKED=$(echo "${var}" | jq -r '.masked')
            RAW=$(echo "${var}" | jq -r '.raw // false')
          
            ISSUES=""
            if [ "${PROTECTED}" != "true" ]; then
              ISSUES="${ISSUES} unprotected"
            fi
            if [ "${MASKED}" != "true" ]; then
              ISSUES="${ISSUES} unmasked"
            fi
            if [ "${RAW}" == "true" ]; then
              ISSUES="${ISSUES} raw-exposed"
            fi
          
            if [ -n "${ISSUES}" ]; then
              warn "2.1 Variable '${KEY}':${ISSUES}"
            else
              pass "2.1 Variable '${KEY}': protected + masked"
            fi
            done
          
            # Summary counts (re-parse for totals since while-loop runs in subshell)
            UNPROTECTED=$(echo "${VARIABLES}" | jq '[.[] | select(.protected != true)] | length' 2>/dev/null || echo "0")
            UNMASKED=$(echo "${VARIABLES}" | jq '[.[] | select(.masked != true)] | length' 2>/dev/null || echo "0")
            RAW_EXPOSED=$(echo "${VARIABLES}" | jq '[.[] | select(.raw == true)] | length' 2>/dev/null || echo "0")
          
            info "2.1 Unprotected: ${UNPROTECTED}, Unmasked: ${UNMASKED}, Raw-exposed: ${RAW_EXPOSED}"

"4.1":
  api:
    lang: "bash"
    filename: "hth-gitlab-4.01-enable-push-rules.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/api/hth-gitlab-4.01-enable-push-rules.sh"
    excerpts:
      api-configure-push-rules:
        content: |
            # Configure push rules: L1 enables prevent_secrets and deny_delete_tag;
            # L2 additionally enables reject_unsigned_commits for commit signing enforcement.
            info "4.1 Configuring push rules..."
          
            PAYLOAD='{
            "prevent_secrets": true,
            "deny_delete_tag": true'
          
            # L2: Add reject_unsigned_commits
            if should_apply 2 2>/dev/null; then
            info "4.1 L2: Enabling reject_unsigned_commits (commit signing required)"
            PAYLOAD="${PAYLOAD}"',"reject_unsigned_commits": true'
            fi
          
            PAYLOAD="${PAYLOAD}"'}'
          
            if [ -n "${EXISTING}" ] && [ "${EXISTING}" != "null" ]; then
            # Update existing push rules
            RESULT=$(gl_put "/projects/${PROJECT_ID}/push_rule" "${PAYLOAD}" 2>/dev/null) || {
              fail "4.1 Failed to update push rules"
              increment_failed
              summary
              exit 0
            }
            else
            # Create new push rules
            RESULT=$(gl_post "/projects/${PROJECT_ID}/push_rule" "${PAYLOAD}" 2>/dev/null) || {
              fail "4.1 Failed to create push rules"
              increment_failed
              summary
              exit 0
            }
            fi
  sigma:
    - lang: "yaml"
      filename: "hth-gitlab-4.01-enable-push-rules.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/siem/sigma/hth-gitlab-4.01-enable-push-rules.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    entity_type: 'PushRule'
                    action:
                        - 'create'
                        - 'update'
                        - 'destroy'
                condition: selection
              fields:
                - author_name
                - entity_path
                - target_details
                - ip_address
                - created_at

"6.1":
  api:
    lang: "bash"
    filename: "hth-gitlab-6.01-enable-audit-events.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/api/hth-gitlab-6.01-enable-audit-events.sh"
    excerpts:
      api-query-audit-events:
        content: |
            # Query group-level audit events and verify audit logging is active.
            # GitLab Premium/Ultimate exposes audit events via the REST API.
            info "6.1 Retrieving recent audit events..."
            AUDIT_EVENTS=$(gl_get "/groups/${GROUP_ID}/audit_events?per_page=20" 2>/dev/null) || {
            fail "6.1 Failed to retrieve audit events -- requires GitLab Premium/Ultimate and admin token"
            increment_failed
            summary
            exit 0
            }
          
            EVENT_COUNT=$(echo "${AUDIT_EVENTS}" | jq 'length' 2>/dev/null || echo "0")
            info "6.1 Retrieved ${EVENT_COUNT} recent audit event(s)"
          
            if [ "${EVENT_COUNT}" -gt 0 ]; then
            # Show recent security-relevant events
            echo "${AUDIT_EVENTS}" | jq -r '.[] | "  - [\(.created_at)] \(.author.name // .author_id): \(.entity_type)/\(.details.action // .details.custom_message // "event")"' 2>/dev/null || true
          
            # Check for key security event types
            info "6.1 Checking for security-relevant event categories..."
            AUTH_EVENTS=$(echo "${AUDIT_EVENTS}" | jq '[.[] | select(.details.action // "" | test("auth|login|session"; "i"))] | length' 2>/dev/null || echo "0")
            PERM_EVENTS=$(echo "${AUDIT_EVENTS}" | jq '[.[] | select(.details.action // "" | test("permission|role|access"; "i"))] | length' 2>/dev/null || echo "0")
            REPO_EVENTS=$(echo "${AUDIT_EVENTS}" | jq '[.[] | select(.details.action // "" | test("push|merge|branch|tag"; "i"))] | length' 2>/dev/null || echo "0")
          
            info "6.1 Event breakdown: auth=${AUTH_EVENTS}, permissions=${PERM_EVENTS}, repository=${REPO_EVENTS}"
            fi
          
            # Check for audit event streaming destinations (L2)
            if should_apply 2 2>/dev/null; then
            info "6.1 L2: Checking external audit event streaming destinations..."
            STREAM_DESTS=$(gl_get "/groups/${GROUP_ID}/audit_events/streaming/destinations" 2>/dev/null || echo "[]")
            DEST_COUNT=$(echo "${STREAM_DESTS}" | jq 'length' 2>/dev/null || echo "0")
          
            if [ "${DEST_COUNT}" -gt 0 ]; then
              pass "6.1 Found ${DEST_COUNT} audit event streaming destination(s)"
              echo "${STREAM_DESTS}" | jq -r '.[] | "  - \(.destination_url // "unknown") (verification: \(.verification_token | if . then "set" else "unset" end))"' 2>/dev/null || true
            else
              warn "6.1 No external audit event streaming destinations configured"
              warn "6.1 Configure via Settings > General > Audit events > Streaming to forward to your SIEM"
            fi
            fi
  sigma:
    - lang: "yaml"
      filename: "hth-gitlab-6.01-enable-audit-events.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/siem/sigma/hth-gitlab-6.01-enable-audit-events.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection_destination:
                    entity_type: 'ExternalAuditEventDestination'
                    action: 'destroy'
                selection_header:
                    entity_type: 'AuditEventsStreamingHeader'
                    action: 'destroy'
                condition: selection_destination or selection_header
              fields:
                - author_name
                - entity_path
                - target_details
                - ip_address
                - created_at

