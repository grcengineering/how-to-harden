# AUTO-GENERATED by scripts/sync-packs-to-data.sh â€” do not edit manually
# Generated: 2026-02-19T16:14:13Z

"1.1":
  cli:
    lang: "ruby"
    filename: "hth-gitlab-1.01-configure-saml-sso.rb"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/cli/hth-gitlab-1.01-configure-saml-sso.rb"
    excerpts:
      cli-configure-saml-sso:
        content: |
            # /etc/gitlab/gitlab.rb
          
            # SAML Configuration
            gitlab_rails['omniauth_enabled'] = true
            gitlab_rails['omniauth_allow_single_sign_on'] = ['saml']
            gitlab_rails['omniauth_block_auto_created_users'] = false
            gitlab_rails['omniauth_providers'] = [
            {
              name: 'saml',
              args: {
                assertion_consumer_service_url: 'https://gitlab.company.com/users/auth/saml/callback',
                idp_cert_fingerprint: 'XX:XX:XX...',
                idp_sso_target_url: 'https://idp.company.com/saml/sso',
                issuer: 'https://gitlab.company.com',
                name_identifier_format: 'urn:oasis:names:tc:SAML:2.0:nameid-format:persistent'
              }
            }
            ]
          
            # Disable password authentication
            gitlab_rails['gitlab_signin_enabled'] = false

"1.3":
  api:
    lang: "bash"
    filename: "hth-gitlab-1.03-configure-personal-access-token-policies.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/api/hth-gitlab-1.03-configure-personal-access-token-policies.sh"
    excerpts:
      api-audit-pat-policies:
        content: |
            # List all active personal access tokens and flag risky configurations
            info "1.3 Retrieving active personal access tokens..."
            PAGE=1
            ALL_PATS="[]"
            while true; do
            RESPONSE=$(gl_get "/personal_access_tokens?state=active&per_page=100&page=${PAGE}" 2>/dev/null) || break
            COUNT=$(echo "${RESPONSE}" | jq 'length' 2>/dev/null || echo "0")
            [ "${COUNT}" -eq 0 ] && break
            ALL_PATS=$(echo "${ALL_PATS} ${RESPONSE}" | jq -s 'add')
            PAGE=$((PAGE + 1))
            done
          
            TOTAL=$(echo "${ALL_PATS}" | jq 'length' 2>/dev/null || echo "0")
            info "1.3 Found ${TOTAL} active personal access token(s)"
          
            # Flag tokens with overly broad 'api' scope
            API_SCOPE_PATS=$(echo "${ALL_PATS}" | jq '[.[] | select(.scopes | index("api"))]' 2>/dev/null || echo "[]")
            API_SCOPE_COUNT=$(echo "${API_SCOPE_PATS}" | jq 'length' 2>/dev/null || echo "0")
          
            if [ "${API_SCOPE_COUNT}" -gt 0 ]; then
            warn "1.3 Found ${API_SCOPE_COUNT} token(s) with full 'api' scope (overly permissive)"
            echo "${API_SCOPE_PATS}" | jq -r '.[] | "  - \(.name // "unnamed") (user: \(.user_id // "unknown"), created: \(.created_at // "unknown"))"' 2>/dev/null || true
            fi
          
            # Flag tokens with no expiration date
            NO_EXPIRY_PATS=$(echo "${ALL_PATS}" | jq '[.[] | select(.expires_at == null)]' 2>/dev/null || echo "[]")
            NO_EXPIRY_COUNT=$(echo "${NO_EXPIRY_PATS}" | jq 'length' 2>/dev/null || echo "0")
          
            if [ "${NO_EXPIRY_COUNT}" -gt 0 ]; then
            warn "1.3 Found ${NO_EXPIRY_COUNT} token(s) with no expiration date"
            echo "${NO_EXPIRY_PATS}" | jq -r '.[] | "  - \(.name // "unnamed") (user: \(.user_id // "unknown"), scopes: \(.scopes | join(", ")))"' 2>/dev/null || true
            fi
          
            # Flag tokens with write_repository scope (supply chain risk)
            WRITE_REPO_PATS=$(echo "${ALL_PATS}" | jq '[.[] | select(.scopes | index("write_repository"))]' 2>/dev/null || echo "[]")
            WRITE_REPO_COUNT=$(echo "${WRITE_REPO_PATS}" | jq 'length' 2>/dev/null || echo "0")
          
            if [ "${WRITE_REPO_COUNT}" -gt 0 ]; then
            warn "1.3 Found ${WRITE_REPO_COUNT} token(s) with 'write_repository' scope"
            echo "${WRITE_REPO_PATS}" | jq -r '.[] | "  - \(.name // "unnamed") (user: \(.user_id // "unknown"), expires: \(.expires_at // "never"))"' 2>/dev/null || true
            fi
  sigma:
    - lang: "yaml"
      filename: "hth-gitlab-1.03-configure-personal-access-token-policies.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/siem/sigma/hth-gitlab-1.03-configure-personal-access-token-policies.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    entity_type: 'PersonalAccessToken'
                    action: 'create'
                condition: selection
              fields:
                - author_name
                - entity_path
                - target_details
                - ip_address
                - created_at

"2.1":
  api:
    lang: "bash"
    filename: "hth-gitlab-2.01-protect-cicd-variables.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/api/hth-gitlab-2.01-protect-cicd-variables.sh"
    excerpts:
      api-audit-cicd-variables:
        content: |
            # Retrieve all project-level CI/CD variables and check protection settings
            VARIABLES=$(gl_get "/projects/${PROJECT_ID}/variables" 2>/dev/null) || {
            fail "2.1 Failed to retrieve CI/CD variables -- check PROJECT_ID and token permissions"
            increment_failed
            summary
            exit 0
            }
          
            VAR_COUNT=$(echo "${VARIABLES}" | jq 'length' 2>/dev/null || echo "0")
            info "2.1 Found ${VAR_COUNT} CI/CD variable(s)"
          
            UNPROTECTED=0
            UNMASKED=0
            RAW_EXPOSED=0
          
            echo "${VARIABLES}" | jq -c '.[]' 2>/dev/null | while IFS= read -r var; do
            KEY=$(echo "${var}" | jq -r '.key')
            PROTECTED=$(echo "${var}" | jq -r '.protected')
            MASKED=$(echo "${var}" | jq -r '.masked')
            RAW=$(echo "${var}" | jq -r '.raw // false')
          
            ISSUES=""
            if [ "${PROTECTED}" != "true" ]; then
              ISSUES="${ISSUES} unprotected"
            fi
            if [ "${MASKED}" != "true" ]; then
              ISSUES="${ISSUES} unmasked"
            fi
            if [ "${RAW}" == "true" ]; then
              ISSUES="${ISSUES} raw-exposed"
            fi
          
            if [ -n "${ISSUES}" ]; then
              warn "2.1 Variable '${KEY}':${ISSUES}"
            else
              pass "2.1 Variable '${KEY}': protected + masked"
            fi
            done
          
            # Summary counts (re-parse for totals since while-loop runs in subshell)
            UNPROTECTED=$(echo "${VARIABLES}" | jq '[.[] | select(.protected != true)] | length' 2>/dev/null || echo "0")
            UNMASKED=$(echo "${VARIABLES}" | jq '[.[] | select(.masked != true)] | length' 2>/dev/null || echo "0")
            RAW_EXPOSED=$(echo "${VARIABLES}" | jq '[.[] | select(.raw == true)] | length' 2>/dev/null || echo "0")
          
            info "2.1 Unprotected: ${UNPROTECTED}, Unmasked: ${UNMASKED}, Raw-exposed: ${RAW_EXPOSED}"

"3.1":
  cli:
    lang: "bash"
    filename: "hth-gitlab-3.01-isolate-cicd-runners.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/cli/hth-gitlab-3.01-isolate-cicd-runners.sh"
    excerpts:
      cli-register-runner:
        content: |
            # Register runner with specific tags
            gitlab-runner register \
            --url "https://gitlab.company.com" \
            --registration-token "${RUNNER_TOKEN}" \
            --executor "docker" \
            --docker-image "alpine:3.18" \
            --tag-list "isolated,security-sensitive" \
            --run-untagged="false" \
            --locked="true"
      cli-runner-config:
        content: |
            [[runners]]
            name = "secure-runner"
            executor = "docker"
            [runners.docker]
              image = "alpine:3.18"
              privileged = false  # Never enable unless absolutely required
              disable_entrypoint_overwrite = true
              volumes = ["/cache"]
              # Limit network access
              network_mode = "bridge"
              # Read-only root filesystem
              read_only = true
              # Drop capabilities
              cap_drop = ["ALL"]

"3.2":
  cli:
    lang: "bash"
    filename: "hth-gitlab-3.02-rotate-runner-token.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/cli/hth-gitlab-3.02-rotate-runner-token.sh"
    excerpts:
      cli-rotate-runner-token:
        content: |
            # Reset project runner token
            curl -X POST -H "PRIVATE-TOKEN: ${ADMIN_TOKEN}" \
            "https://gitlab.company.com/api/v4/projects/${PROJECT_ID}/runners/reset_registration_token"
          
            # Re-register runner
            gitlab-runner unregister --all-runners
            gitlab-runner register --non-interactive \
            --url "https://gitlab.company.com" \
            --registration-token "${NEW_TOKEN}" \
            --executor "docker"

"4.1":
  api:
    lang: "bash"
    filename: "hth-gitlab-4.01-enable-push-rules.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/api/hth-gitlab-4.01-enable-push-rules.sh"
    excerpts:
      api-configure-push-rules:
        content: |
            # Configure push rules: L1 enables prevent_secrets and deny_delete_tag;
            # L2 additionally enables reject_unsigned_commits for commit signing enforcement.
            info "4.1 Configuring push rules..."
          
            PAYLOAD='{
            "prevent_secrets": true,
            "deny_delete_tag": true'
          
            # L2: Add reject_unsigned_commits
            if should_apply 2 2>/dev/null; then
            info "4.1 L2: Enabling reject_unsigned_commits (commit signing required)"
            PAYLOAD="${PAYLOAD}"',"reject_unsigned_commits": true'
            fi
          
            PAYLOAD="${PAYLOAD}"'}'
          
            if [ -n "${EXISTING}" ] && [ "${EXISTING}" != "null" ]; then
            # Update existing push rules
            RESULT=$(gl_put "/projects/${PROJECT_ID}/push_rule" "${PAYLOAD}" 2>/dev/null) || {
              fail "4.1 Failed to update push rules"
              increment_failed
              summary
              exit 0
            }
            else
            # Create new push rules
            RESULT=$(gl_post "/projects/${PROJECT_ID}/push_rule" "${PAYLOAD}" 2>/dev/null) || {
              fail "4.1 Failed to create push rules"
              increment_failed
              summary
              exit 0
            }
            fi
  sigma:
    - lang: "yaml"
      filename: "hth-gitlab-4.01-enable-push-rules.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/siem/sigma/hth-gitlab-4.01-enable-push-rules.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    entity_type: 'PushRule'
                    action:
                        - 'create'
                        - 'update'
                        - 'destroy'
                condition: selection
              fields:
                - author_name
                - entity_path
                - target_details
                - ip_address
                - created_at

"5.1":
  cli:
    lang: "yaml"
    filename: "hth-gitlab-5.01-vault-integration.yml"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/cli/hth-gitlab-5.01-vault-integration.yml"
    excerpts:
      cli-vault-integration:
        content: |
            # .gitlab-ci.yml
            deploy:
            stage: deploy
            secrets:
              DATABASE_PASSWORD:
                vault: production/db/password@secret
              API_KEY:
                vault: production/api/key@secret
            script:
              - echo "Using secrets from Vault"
              - ./deploy.sh

"6.1":
  api:
    lang: "bash"
    filename: "hth-gitlab-6.01-enable-audit-events.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/api/hth-gitlab-6.01-enable-audit-events.sh"
    excerpts:
      api-query-audit-events:
        content: |
            # Query group-level audit events and verify audit logging is active.
            # GitLab Premium/Ultimate exposes audit events via the REST API.
            info "6.1 Retrieving recent audit events..."
            AUDIT_EVENTS=$(gl_get "/groups/${GROUP_ID}/audit_events?per_page=20" 2>/dev/null) || {
            fail "6.1 Failed to retrieve audit events -- requires GitLab Premium/Ultimate and admin token"
            increment_failed
            summary
            exit 0
            }
          
            EVENT_COUNT=$(echo "${AUDIT_EVENTS}" | jq 'length' 2>/dev/null || echo "0")
            info "6.1 Retrieved ${EVENT_COUNT} recent audit event(s)"
          
            if [ "${EVENT_COUNT}" -gt 0 ]; then
            # Show recent security-relevant events
            echo "${AUDIT_EVENTS}" | jq -r '.[] | "  - [\(.created_at)] \(.author.name // .author_id): \(.entity_type)/\(.details.action // .details.custom_message // "event")"' 2>/dev/null || true
          
            # Check for key security event types
            info "6.1 Checking for security-relevant event categories..."
            AUTH_EVENTS=$(echo "${AUDIT_EVENTS}" | jq '[.[] | select(.details.action // "" | test("auth|login|session"; "i"))] | length' 2>/dev/null || echo "0")
            PERM_EVENTS=$(echo "${AUDIT_EVENTS}" | jq '[.[] | select(.details.action // "" | test("permission|role|access"; "i"))] | length' 2>/dev/null || echo "0")
            REPO_EVENTS=$(echo "${AUDIT_EVENTS}" | jq '[.[] | select(.details.action // "" | test("push|merge|branch|tag"; "i"))] | length' 2>/dev/null || echo "0")
          
            info "6.1 Event breakdown: auth=${AUTH_EVENTS}, permissions=${PERM_EVENTS}, repository=${REPO_EVENTS}"
            fi
          
            # Check for audit event streaming destinations (L2)
            if should_apply 2 2>/dev/null; then
            info "6.1 L2: Checking external audit event streaming destinations..."
            STREAM_DESTS=$(gl_get "/groups/${GROUP_ID}/audit_events/streaming/destinations" 2>/dev/null || echo "[]")
            DEST_COUNT=$(echo "${STREAM_DESTS}" | jq 'length' 2>/dev/null || echo "0")
          
            if [ "${DEST_COUNT}" -gt 0 ]; then
              pass "6.1 Found ${DEST_COUNT} audit event streaming destination(s)"
              echo "${STREAM_DESTS}" | jq -r '.[] | "  - \(.destination_url // "unknown") (verification: \(.verification_token | if . then "set" else "unset" end))"' 2>/dev/null || true
            else
              warn "6.1 No external audit event streaming destinations configured"
              warn "6.1 Configure via Settings > General > Audit events > Streaming to forward to your SIEM"
            fi
            fi
  sigma:
    - lang: "yaml"
      filename: "hth-gitlab-6.01-enable-audit-events.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/gitlab/siem/sigma/hth-gitlab-6.01-enable-audit-events.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection_destination:
                    entity_type: 'ExternalAuditEventDestination'
                    action: 'destroy'
                selection_header:
                    entity_type: 'AuditEventsStreamingHeader'
                    action: 'destroy'
                condition: selection_destination or selection_header
              fields:
                - author_name
                - entity_path
                - target_details
                - ip_address
                - created_at

