# AUTO-GENERATED by scripts/sync-packs-to-data.sh â€” do not edit manually
# Generated: 2026-02-19T19:39:30Z

"1.1":
  terraform:
    lang: "hcl"
    filename: "hth-mongodb-atlas-1.01-configure-ip-access-list.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/mongodb-atlas/terraform/hth-mongodb-atlas-1.01-configure-ip-access-list.tf"
    excerpts:
      terraform:
        content: |
            # -----------------------------------------------------------------------------
            # 1.1 IP Access List Entries
            # Each entry restricts database connections to an approved CIDR range.
            # NEVER include 0.0.0.0/0 -- this opens databases to the entire internet.
            # -----------------------------------------------------------------------------
          
            resource "mongodbatlas_project_ip_access_list" "allowed" {
            for_each = { for idx, entry in var.allowed_cidr_blocks : idx => entry }
          
            project_id = var.atlas_project_id
            cidr_block = each.value.cidr_block
            comment    = each.value.comment
            }
  api:
    lang: "bash"
    filename: "hth-mongodb-atlas-1.01-configure-ip-access-list.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/mongodb-atlas/api/hth-mongodb-atlas-1.01-configure-ip-access-list.sh"
    excerpts:
      api-audit-ip-access:
        content: |
            # Retrieve all IP access list entries for the project
            ACCESS_LIST=$(atlas_get "/groups/${ATLAS_PROJECT_ID}/accessList") || {
            fail "1.1 Failed to retrieve IP access list"
            increment_failed
            summary
            exit 1
            }
          
            TOTAL_ENTRIES=$(echo "${ACCESS_LIST}" | jq '.totalCount // 0')
            info "1.1 Found ${TOTAL_ENTRIES} IP access list entries"
          
            # Check for open access (0.0.0.0/0) -- critical finding
            OPEN_ENTRIES=$(echo "${ACCESS_LIST}" | jq -r '
            .results[]
            | select(.cidrBlock == "0.0.0.0/0" or .cidrBlock == "::/0")
            | .cidrBlock
            ' 2>/dev/null || true)
          
            if [ -n "${OPEN_ENTRIES}" ]; then
            fail "1.1 CRITICAL: Open access entry detected -- databases exposed to entire internet"
            echo "${OPEN_ENTRIES}" | while read -r cidr; do
              fail "  - ${cidr}"
            done
            increment_failed
            else
            pass "1.1 No open access entries (0.0.0.0/0) found"
            increment_applied
            fi
          
            # Report overly broad CIDR blocks (larger than /16)
            BROAD_ENTRIES=$(echo "${ACCESS_LIST}" | jq -r '
            .results[]
            | select(.cidrBlock != null)
            | select(
                (.cidrBlock | split("/") | .[1] | tonumber) < 16
              )
            | "\(.cidrBlock) (\(.comment // "no comment"))"
            ' 2>/dev/null || true)
          
            if [ -n "${BROAD_ENTRIES}" ]; then
            warn "1.1 Overly broad CIDR blocks detected (wider than /16):"
            echo "${BROAD_ENTRIES}" | while read -r entry; do
              warn "  - ${entry}"
            done
            fi
          
            # Check for entries with no comment (poor documentation)
            UNCOMMENTED=$(echo "${ACCESS_LIST}" | jq '[.results[] | select(.comment == null or .comment == "")] | length' 2>/dev/null || echo "0")
            if [ "${UNCOMMENTED}" -gt 0 ]; then
            warn "1.1 ${UNCOMMENTED} access list entries have no comment (add descriptions for audit trail)"
            fi
          
            # Report temporary entries that may have expired or are about to
            TEMP_ENTRIES=$(echo "${ACCESS_LIST}" | jq -r '
            .results[]
            | select(.deleteAfterDate != null)
            | "\(.cidrBlock) expires \(.deleteAfterDate)"
            ' 2>/dev/null || true)
          
            if [ -n "${TEMP_ENTRIES}" ]; then
            info "1.1 Temporary access list entries:"
            echo "${TEMP_ENTRIES}" | while read -r entry; do
              info "  - ${entry}"
            done
            fi
  sigma:
    - lang: "yaml"
      filename: "hth-mongodb-atlas-1.01-configure-ip-access-list.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/mongodb-atlas/siem/sigma/hth-mongodb-atlas-1.01-configure-ip-access-list.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    eventTypeName:
                        - 'ACCESS_LIST_ENTRY_ADDED'
                        - 'PROJECT_IP_ACCESS_LIST_ENTRY_ADDED'
                filter_open_access:
                    cidrBlock|contains:
                        - '0.0.0.0/0'
                        - '::/0'
                condition: selection and filter_open_access
              fields:
                - username
                - remoteAddress
                - cidrBlock
                - groupId
                - created

"2.1":
  terraform:
    lang: "hcl"
    filename: "hth-mongodb-atlas-2.01-configure-database-users.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/mongodb-atlas/terraform/hth-mongodb-atlas-2.01-configure-database-users.tf"
    excerpts:
      terraform:
        content: |
            # -----------------------------------------------------------------------------
            # 2.1 Database Users with Scoped Roles
            # Each user receives only the minimum permissions needed. Roles are scoped
            # to specific databases rather than granted project-wide. Avoid atlasAdmin
            # and readWriteAnyDatabase unless absolutely required and documented.
            # -----------------------------------------------------------------------------
          
            resource "mongodbatlas_database_user" "users" {
            for_each = { for idx, user in var.database_users : user.username => user }
          
            project_id         = var.atlas_project_id
            username           = each.value.username
            password           = each.value.password
            auth_database_name = each.value.auth_database
          
            dynamic "roles" {
              for_each = each.value.roles
              content {
                role_name       = roles.value.role_name
                database_name   = roles.value.database_name
                collection_name = roles.value.collection_name
              }
            }
          
            dynamic "scopes" {
              for_each = each.value.scopes
              content {
                name = scopes.value.name
                type = scopes.value.type
              }
            }
            }
  api:
    lang: "bash"
    filename: "hth-mongodb-atlas-2.01-configure-database-users.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/mongodb-atlas/api/hth-mongodb-atlas-2.01-configure-database-users.sh"
    excerpts:
      api-audit-database-users:
        content: |
            # Retrieve all database users for the project
            DB_USERS=$(atlas_get "/groups/${ATLAS_PROJECT_ID}/databaseUsers") || {
            fail "2.1 Failed to retrieve database users"
            increment_failed
            summary
            exit 1
            }
          
            TOTAL_USERS=$(echo "${DB_USERS}" | jq '.totalCount // 0')
            info "2.1 Found ${TOTAL_USERS} database users"
          
            # Check for users with atlasAdmin role on all databases (overly permissive)
            ADMIN_USERS=$(echo "${DB_USERS}" | jq -r '
            .results[]
            | select(
                .roles[]
                | select(.roleName == "atlasAdmin" and (.databaseName == "admin" or .databaseName == ""))
              )
            | .username
            ' 2>/dev/null | sort -u || true)
          
            if [ -n "${ADMIN_USERS}" ]; then
            fail "2.1 Users with atlasAdmin role detected (overly permissive):"
            echo "${ADMIN_USERS}" | while read -r user; do
              fail "  - ${user}"
            done
            increment_failed
            else
            pass "2.1 No users with unrestricted atlasAdmin role"
            increment_applied
            fi
          
            # Check for users with readWriteAnyDatabase (broad access)
            BROAD_USERS=$(echo "${DB_USERS}" | jq -r '
            .results[]
            | select(
                .roles[]
                | select(.roleName == "readWriteAnyDatabase")
              )
            | .username
            ' 2>/dev/null | sort -u || true)
          
            if [ -n "${BROAD_USERS}" ]; then
            warn "2.1 Users with readWriteAnyDatabase role (consider scoping to specific databases):"
            echo "${BROAD_USERS}" | while read -r user; do
              warn "  - ${user}"
            done
            fi
          
            # Check for users authenticating with SCRAM (password) vs X.509 or LDAP
            SCRAM_USERS=$(echo "${DB_USERS}" | jq '[.results[] | select(.databaseName == "admin")] | length' 2>/dev/null || echo "0")
            X509_USERS=$(echo "${DB_USERS}" | jq '[.results[] | select(.databaseName == "$external" and .x509Type != "NONE")] | length' 2>/dev/null || echo "0")
            LDAP_USERS=$(echo "${DB_USERS}" | jq '[.results[] | select(.ldapAuthType != null and .ldapAuthType != "NONE")] | length' 2>/dev/null || echo "0")
          
            info "2.1 Authentication breakdown:"
            info "  - SCRAM (password): ${SCRAM_USERS}"
            info "  - X.509 certificate: ${X509_USERS}"
            info "  - LDAP: ${LDAP_USERS}"
          
            if [ "${SCRAM_USERS}" -gt 0 ] && should_apply 2 2>/dev/null; then
            warn "2.1 L2 recommends migrating SCRAM users to X.509 or LDAP authentication"
            fi
          
            # Check for users with no role scoping (roles on all clusters)
            UNSCOPED_USERS=$(echo "${DB_USERS}" | jq -r '
            .results[]
            | select(.scopes == null or (.scopes | length) == 0)
            | .username
            ' 2>/dev/null || true)
          
            if [ -n "${UNSCOPED_USERS}" ]; then
            warn "2.1 Users with no cluster scope (access to all clusters in project):"
            echo "${UNSCOPED_USERS}" | while read -r user; do
              warn "  - ${user}"
            done
            fi

"3.2":
  terraform:
    lang: "hcl"
    filename: "hth-mongodb-atlas-3.02-configure-customer-key-management.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/mongodb-atlas/terraform/hth-mongodb-atlas-3.02-configure-customer-key-management.tf"
    excerpts:
      terraform:
        content: |
            # -----------------------------------------------------------------------------
            # 3.2 Encryption at Rest with Customer-Managed Keys (AWS KMS)
            # Enables customer-controlled encryption keys so the organization retains
            # full control over the key lifecycle (rotation, revocation, audit).
            # Atlas uses envelope encryption: the CMK wraps the data encryption key.
            # -----------------------------------------------------------------------------
          
            resource "mongodbatlas_encryption_at_rest" "cmk" {
            project_id = var.atlas_project_id
          
            aws_kms_config {
              enabled                = true
              customer_master_key_id = var.aws_kms_key_id
              region                 = var.aws_kms_region
              access_key_id          = var.aws_access_key_id
              secret_access_key      = var.aws_secret_access_key
              role_id                = var.aws_role_arn != "" ? var.aws_role_arn : null
            }
            }

"4.1":
  terraform:
    lang: "hcl"
    filename: "hth-mongodb-atlas-4.01-enable-database-auditing.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/mongodb-atlas/terraform/hth-mongodb-atlas-4.01-enable-database-auditing.tf"
    excerpts:
      terraform:
        content: |
            # -----------------------------------------------------------------------------
            # 4.1 Database Auditing
            # Captures authentication, authorization, and DDL events. The audit filter
            # controls which operations are logged. Enable audit_authorization_success
            # at L2+ for full authorization visibility (higher log volume).
            # -----------------------------------------------------------------------------
          
            resource "mongodbatlas_auditing" "config" {
            project_id                  = var.atlas_project_id
            audit_filter                = var.audit_filter
            audit_authorization_success = var.audit_authorization_success
            enabled                     = true
            }
  api:
    lang: "bash"
    filename: "hth-mongodb-atlas-4.01-enable-database-auditing.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/mongodb-atlas/api/hth-mongodb-atlas-4.01-enable-database-auditing.sh"
    excerpts:
      api-enable-auditing:
        content: |
            # Retrieve current auditing configuration
            AUDIT_CONFIG=$(atlas_get "/groups/${ATLAS_PROJECT_ID}/auditing") || {
            fail "4.1 Failed to retrieve auditing configuration (requires M10+ cluster)"
            increment_failed
            summary
            exit 1
            }
          
            AUDIT_ENABLED=$(echo "${AUDIT_CONFIG}" | jq -r '.enabled // false')
            AUDIT_FILTER=$(echo "${AUDIT_CONFIG}" | jq -r '.auditFilter // "none"')
            AUDIT_AUTH_SUCCESS=$(echo "${AUDIT_CONFIG}" | jq -r '.auditAuthorizationSuccess // false')
          
            if [ "${AUDIT_ENABLED}" = "true" ]; then
            pass "4.1 Database auditing is enabled"
            info "4.1 Current audit filter: ${AUDIT_FILTER}"
            info "4.1 Audit authorization success: ${AUDIT_AUTH_SUCCESS}"
            increment_applied
            else
            warn "4.1 Database auditing is DISABLED -- enabling now..."
          
            # Enable auditing with a comprehensive filter
            AUDIT_PAYLOAD='{
              "enabled": true,
              "auditFilter": "{\"$or\":[{\"users\":[]},{\"atype\":{\"$in\":[\"authCheck\",\"authenticate\",\"createCollection\",\"createDatabase\",\"createIndex\",\"dropCollection\",\"dropDatabase\",\"dropIndex\",\"createUser\",\"dropUser\",\"updateUser\",\"grantRolesToUser\",\"revokeRolesFromUser\",\"createRole\",\"dropRole\",\"updateRole\",\"shutdown\"]}}]}",
              "auditAuthorizationSuccess": false
            }'
          
            RESULT=$(atlas_patch "/groups/${ATLAS_PROJECT_ID}/auditing" "${AUDIT_PAYLOAD}") || {
              fail "4.1 Failed to enable auditing"
              increment_failed
              summary
              exit 1
            }
          
            NEW_STATUS=$(echo "${RESULT}" | jq -r '.enabled // false')
            if [ "${NEW_STATUS}" = "true" ]; then
              pass "4.1 Database auditing enabled successfully"
              increment_applied
            else
              fail "4.1 Auditing enable request returned but status is still disabled"
              increment_failed
            fi
            fi
          
            # L2 check: audit authorization success should be enabled
            if should_apply 2 2>/dev/null; then
            if [ "${AUDIT_AUTH_SUCCESS}" != "true" ]; then
              warn "4.1 L2 recommends enabling auditAuthorizationSuccess for full visibility"
            else
              pass "4.1 L2: auditAuthorizationSuccess is enabled"
            fi
            fi
  sigma:
    - lang: "yaml"
      filename: "hth-mongodb-atlas-4.01-enable-database-auditing.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/mongodb-atlas/siem/sigma/hth-mongodb-atlas-4.01-enable-database-auditing.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    eventTypeName:
                        - 'AUDIT_CONFIGURATION_UPDATED'
                        - 'PROJECT_AUDIT_CONFIGURATION_UPDATED'
                filter_disabled:
                    enabled: false
                condition: selection and filter_disabled
              fields:
                - username
                - remoteAddress
                - groupId
                - enabled
                - auditFilter
                - created

