# AUTO-GENERATED by scripts/sync-packs-to-data.sh â€” do not edit manually
# Generated: 2026-02-19T16:14:43Z

"1.1":
  terraform:
    lang: "hcl"
    filename: "hth-snowflake-1.01-enforce-mfa.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/terraform/hth-snowflake-1.01-enforce-mfa.tf"
    excerpts:
      terraform:
        content: |
            # Authentication policy requiring MFA for all human users
            resource "snowflake_authentication_policy" "require_mfa" {
            name     = "HTH_REQUIRE_MFA"
            database = "SNOWFLAKE"
            schema   = "PUBLIC"
            comment  = "HTH: Enforce MFA for all human users (Control 1.1)"
          
            mfa_authentication_methods = ["TOTP"]
            client_types               = ["SNOWFLAKE_UI", "SNOWSQL", "DRIVERS"]
            }
          
            # Attach authentication policy at account level
            resource "snowflake_account_parameter" "require_mfa" {
            key   = "AUTHENTICATION_POLICY"
            value = snowflake_authentication_policy.require_mfa.name
            }
          
            # Ensure service accounts use key-pair auth (excluded from MFA)
            # Service accounts should be created with TYPE = SERVICE and key-pair auth
            resource "snowflake_user" "service_account_example" {
            count = var.create_example_service_account ? 1 : 0
          
            name          = "HTH_SVC_EXAMPLE"
            login_name    = "hth_svc_example"
            comment       = "HTH: Example service account with key-pair auth (Control 1.1/1.2)"
            disabled      = false
            default_role  = "HTH_DATA_READER"
            rsa_public_key = var.service_account_rsa_public_key
            }
  api:
    lang: "bash"
    filename: "hth-snowflake-1.01-enforce-mfa.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/api/hth-snowflake-1.01-enforce-mfa.sh"
    excerpts:
      audit-mfa-enrollment:
        content: |
            # Identify users without MFA enrolled
            MFA_AUDIT=$(snow_query "
            SELECT
              name,
              login_name,
              ext_authn_duo,
              has_rsa_public_key,
              disabled,
              last_success_login
            FROM SNOWFLAKE.ACCOUNT_USAGE.USERS
            WHERE deleted_on IS NULL
            AND disabled = 'false'
            ORDER BY name;
            ") || {
            fail "1.1 Failed to query user MFA status"
            increment_failed
            summary
            exit 0
            }
          
            # Count users without MFA
            NO_MFA_COUNT=$(echo "${MFA_AUDIT}" | jq '[.[] | select(.EXT_AUTHN_DUO == "false" and .HAS_RSA_PUBLIC_KEY == "false")] | length' 2>/dev/null || echo "unknown")
            TOTAL_COUNT=$(echo "${MFA_AUDIT}" | jq 'length' 2>/dev/null || echo "unknown")
      create-authentication-policy:
        content: |
            # Create authentication policy requiring MFA for all users
            info "1.1 Creating authentication policy to enforce MFA..."
            snow_exec "
            CREATE AUTHENTICATION POLICY IF NOT EXISTS hth_require_mfa
            MFA_AUTHENTICATION_METHODS = ('TOTP')
            CLIENT_TYPES = ('SNOWFLAKE_UI', 'SNOWSQL', 'DRIVERS')
            SECURITY_INTEGRATIONS = ()
            COMMENT = 'HTH: Enforce MFA for all human users (Control 1.1)';
            " > /dev/null 2>&1 || {
              fail "1.1 Failed to create authentication policy"
              increment_failed
              summary
              exit 0
            }
          
            # Attach policy at account level
            info "1.1 Attaching authentication policy to account..."
            snow_exec "
            ALTER ACCOUNT SET AUTHENTICATION POLICY hth_require_mfa;
            " > /dev/null 2>&1 || {
              warn "1.1 Could not attach policy at account level (may require ACCOUNTADMIN)"
              increment_failed
              summary
              exit 0
            }
  sigma:
    - lang: "yaml"
      filename: "hth-snowflake-1.01-mfa-bypass-attempt.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/siem/sigma/hth-snowflake-1.01-mfa-bypass-attempt.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    event_type: 'LOGIN'
                    is_success: 'YES'
                filter_mfa:
                    second_authentication_factor|contains:
                        - 'MFA_TOKEN'
                        - 'DUO_PASSCODE'
                filter_keypair:
                    first_authentication_factor: 'RSA_KEYPAIR'
                condition: selection and not filter_mfa and not filter_keypair
              fields:
                - user_name
                - client_ip
                - reported_client_type
                - first_authentication_factor
                - second_authentication_factor
                - event_timestamp

"1.2":
  cli:
    lang: "bash"
    filename: "hth-snowflake-1.02-generate-key-pair.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/cli/hth-snowflake-1.02-generate-key-pair.sh"
    excerpts:
      cli-generate-key-pair:
        content: |
            # Generate private key (keep secure!)
            openssl genrsa -out rsa_key.pem 2048
          
            # Generate public key
            openssl rsa -in rsa_key.pem -pubout -out rsa_key.pub
          
            # Extract public key in Snowflake format
            grep -v "PUBLIC KEY" rsa_key.pub | tr -d '\n'
  sdk:
    lang: "python"
    filename: "hth-snowflake-1.02-key-pair-connection.py"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/sdk/hth-snowflake-1.02-key-pair-connection.py"
    excerpts:
      sdk-key-pair-connection:
        content: |
            import snowflake.connector
          
            conn = snowflake.connector.connect(
              account='your_account',
              user='svc_etl_pipeline',
              private_key_file='/path/to/rsa_key.pem',
              warehouse='ETL_WH',
              database='PRODUCTION'
            )
  db:
    lang: "sql"
    filename: "hth-snowflake-1.02-configure-key-pair-auth.sql"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/db/hth-snowflake-1.02-configure-key-pair-auth.sql"
    excerpts:
      db-configure-key-pair:
        content: |
            -- Remove password from service account
            ALTER USER svc_etl_pipeline
              SET RSA_PUBLIC_KEY = 'MIIBIjANBgkqhki...'
              UNSET PASSWORD;
          
            -- Verify
            DESC USER svc_etl_pipeline;

"1.3":
  terraform:
    lang: "hcl"
    filename: "hth-snowflake-1.03-implement-rbac.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/terraform/hth-snowflake-1.03-implement-rbac.tf"
    excerpts:
      terraform:
        content: |
            # Custom functional roles following least-privilege principle
            resource "snowflake_role" "data_reader" {
            name    = "HTH_DATA_READER"
            comment = "HTH: Read-only access to production data (Control 1.3)"
            }
          
            resource "snowflake_role" "data_writer" {
            name    = "HTH_DATA_WRITER"
            comment = "HTH: Read-write access to production data (Control 1.3)"
            }
          
            resource "snowflake_role" "data_analyst" {
            name    = "HTH_DATA_ANALYST"
            comment = "HTH: Analyst role with warehouse and read access (Control 1.3)"
            }
          
            resource "snowflake_role" "security_admin" {
            name    = "HTH_SECURITY_ADMIN"
            comment = "HTH: Security administration without full ACCOUNTADMIN (Control 1.3)"
            }
          
            # Role hierarchy: SECURITY_ADMIN -> ACCOUNTADMIN, DATA_WRITER -> SYSADMIN
            resource "snowflake_role_grants" "reader_to_writer" {
            role_name = snowflake_role.data_reader.name
            roles     = [snowflake_role.data_writer.name]
            }
          
            resource "snowflake_role_grants" "reader_to_analyst" {
            role_name = snowflake_role.data_reader.name
            roles     = [snowflake_role.data_analyst.name]
            }
          
            resource "snowflake_role_grants" "writer_to_sysadmin" {
            role_name = snowflake_role.data_writer.name
            roles     = ["SYSADMIN"]
            }
          
            resource "snowflake_role_grants" "security_to_accountadmin" {
            role_name = snowflake_role.security_admin.name
            roles     = ["ACCOUNTADMIN"]
            }
          
            # Grant read permissions on target database to DATA_READER
            resource "snowflake_database_grant" "reader_usage" {
            count = var.target_database != "" ? 1 : 0
          
            database_name = var.target_database
            privilege     = "USAGE"
            roles         = [snowflake_role.data_reader.name]
            }
          
            resource "snowflake_schema_grant" "reader_usage" {
            count = var.target_database != "" ? 1 : 0
          
            database_name = var.target_database
            privilege     = "USAGE"
            on_all        = true
            roles         = [snowflake_role.data_reader.name]
            }
          
            resource "snowflake_table_grant" "reader_select" {
            count = var.target_database != "" ? 1 : 0
          
            database_name = var.target_database
            privilege     = "SELECT"
            on_all        = true
            roles         = [snowflake_role.data_reader.name]
            }
  api:
    lang: "bash"
    filename: "hth-snowflake-1.03-implement-rbac.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/api/hth-snowflake-1.03-implement-rbac.sh"
    excerpts:
      audit-accountadmin:
        content: |
            # Audit ACCOUNTADMIN grants -- this role should have minimal direct assignments
            info "1.3 Auditing ACCOUNTADMIN role grants..."
            ADMIN_GRANTS=$(snow_query "SHOW GRANTS OF ROLE ACCOUNTADMIN;") || {
            fail "1.3 Failed to query ACCOUNTADMIN grants"
            increment_failed
            summary
            exit 0
            }
          
            ADMIN_COUNT=$(echo "${ADMIN_GRANTS}" | jq '[.[] | select(.granted_to == "USER")] | length' 2>/dev/null || echo "unknown")
          
            if [ "${ADMIN_COUNT}" -gt 2 ]; then
            warn "1.3 ACCOUNTADMIN granted to ${ADMIN_COUNT} users (recommend <= 2)"
            echo "${ADMIN_GRANTS}" | jq -r '.[] | select(.granted_to == "USER") | "  - \(.grantee_name)"' 2>/dev/null || true
            else
            pass "1.3 ACCOUNTADMIN grant count is acceptable (${ADMIN_COUNT} users)"
            fi
      create-custom-roles:
        content: |
            # Create custom role hierarchy following least-privilege principle
            info "1.3 Creating custom role hierarchy..."
            snow_exec "
            -- Functional roles
            CREATE ROLE IF NOT EXISTS HTH_DATA_READER
            COMMENT = 'HTH: Read-only access to production data (Control 1.3)';
            CREATE ROLE IF NOT EXISTS HTH_DATA_WRITER
            COMMENT = 'HTH: Read-write access to production data (Control 1.3)';
            CREATE ROLE IF NOT EXISTS HTH_DATA_ANALYST
            COMMENT = 'HTH: Analyst role with warehouse usage and read access (Control 1.3)';
            CREATE ROLE IF NOT EXISTS HTH_SECURITY_ADMIN
            COMMENT = 'HTH: Security administration without full ACCOUNTADMIN (Control 1.3)';
          
            -- Role hierarchy: SECURITY_ADMIN -> SYSADMIN -> DATA_WRITER -> DATA_READER
            GRANT ROLE HTH_DATA_READER TO ROLE HTH_DATA_WRITER;
            GRANT ROLE HTH_DATA_READER TO ROLE HTH_DATA_ANALYST;
            GRANT ROLE HTH_DATA_WRITER TO ROLE SYSADMIN;
            GRANT ROLE HTH_SECURITY_ADMIN TO ROLE ACCOUNTADMIN;
            " > /dev/null 2>&1 || {
            fail "1.3 Failed to create custom role hierarchy"
            increment_failed
            summary
            exit 0
            }

"2.1":
  terraform:
    lang: "hcl"
    filename: "hth-snowflake-2.01-implement-network-policies.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/terraform/hth-snowflake-2.01-implement-network-policies.tf"
    excerpts:
      terraform:
        content: |
            # Network policy restricting access to corporate IP ranges
            resource "snowflake_network_policy" "corporate_access" {
            name    = "HTH_CORPORATE_ACCESS"
            comment = "HTH: Restrict account access to corporate IP ranges (Control 2.1)"
          
            allowed_ip_list = var.allowed_ip_list
            blocked_ip_list = var.blocked_ip_list
            }
          
            # Attach network policy at account level
            resource "snowflake_network_policy_attachment" "account_level" {
            network_policy_name = snowflake_network_policy.corporate_access.name
            set_for_account     = true
            }
          
            # Optional: stricter network policy for service accounts
            resource "snowflake_network_policy" "service_accounts" {
            count = length(var.service_account_allowed_ips) > 0 ? 1 : 0
          
            name    = "HTH_SERVICE_ACCOUNT_ACCESS"
            comment = "HTH: Restrict service account access to known IPs (Control 2.1)"
          
            allowed_ip_list = var.service_account_allowed_ips
            blocked_ip_list = []
            }
  api:
    lang: "bash"
    filename: "hth-snowflake-2.01-implement-network-policies.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/api/hth-snowflake-2.01-implement-network-policies.sh"
    excerpts:
      audit-network-policies:
        content: |
            # Audit existing network policies
            info "2.1 Auditing existing network policies..."
            EXISTING_POLICIES=$(snow_query "SHOW NETWORK POLICIES;") || {
            warn "2.1 No network policies found or query failed"
            EXISTING_POLICIES="[]"
            }
          
            POLICY_COUNT=$(echo "${EXISTING_POLICIES}" | jq 'length' 2>/dev/null || echo "0")
          
            if [ "${POLICY_COUNT}" -gt 0 ]; then
            info "2.1 Found ${POLICY_COUNT} existing network policies:"
            echo "${EXISTING_POLICIES}" | jq -r '.[] | "  - \(.name): allowed=\(.allowed_ip_list // "none"), blocked=\(.blocked_ip_list // "none")"' 2>/dev/null || true
            else
            warn "2.1 No network policies configured -- account is accessible from any IP"
            fi
      create-network-policy:
        content: |
            info "2.1 Creating network policy with allowed IPs: ${SNOWFLAKE_ALLOWED_IPS}"
            snow_exec "
            CREATE NETWORK POLICY IF NOT EXISTS hth_corporate_access
            ALLOWED_IP_LIST = (${SNOWFLAKE_ALLOWED_IPS})
            BLOCKED_IP_LIST = ()
            COMMENT = 'HTH: Restrict access to corporate IPs (Control 2.1)';
            " > /dev/null 2>&1 || {
              fail "2.1 Failed to create network policy"
              increment_failed
              summary
              exit 0
            }
          
            # Activate at account level
            info "2.1 Activating network policy at account level..."
            snow_exec "
            ALTER ACCOUNT SET NETWORK_POLICY = 'hth_corporate_access';
            " > /dev/null 2>&1 || {
              fail "2.1 Failed to activate network policy (requires ACCOUNTADMIN)"
              increment_failed
              summary
              exit 0
            }
  sigma:
    - lang: "yaml"
      filename: "hth-snowflake-2.01-network-policy-modified.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/siem/sigma/hth-snowflake-2.01-network-policy-modified.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection_create:
                    query_text|contains:
                        - 'CREATE NETWORK POLICY'
                        - 'CREATE OR REPLACE NETWORK POLICY'
                selection_alter:
                    query_text|contains:
                        - 'ALTER NETWORK POLICY'
                        - 'ALTER ACCOUNT SET NETWORK_POLICY'
                        - 'ALTER ACCOUNT UNSET NETWORK_POLICY'
                selection_drop:
                    query_text|contains:
                        - 'DROP NETWORK POLICY'
                filter_success:
                    execution_status: 'SUCCESS'
                condition: (selection_create or selection_alter or selection_drop) and filter_success
              fields:
                - user_name
                - role_name
                - query_text
                - start_time
                - client_ip
                - execution_status

"3.1":
  terraform:
    lang: "hcl"
    filename: "hth-snowflake-3.01-restrict-oauth-scopes.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/terraform/hth-snowflake-3.01-restrict-oauth-scopes.tf"
    excerpts:
      terraform:
        content: |
            # Snowflake OAuth security integration with restricted scopes
            resource "snowflake_security_integration" "oauth_restricted" {
            name    = "HTH_OAUTH_RESTRICTED"
            type    = "OAUTH"
            comment = "HTH: OAuth integration with restricted scopes and blocked admin roles (Control 3.1)"
          
            oauth_client                       = "CUSTOM"
            oauth_client_type                  = "CONFIDENTIAL"
            oauth_redirect_uri                 = var.oauth_redirect_uri
            oauth_issue_refresh_tokens         = true
            oauth_refresh_token_validity       = var.oauth_refresh_token_validity
            oauth_enforce_pkce                 = "OPTIONAL"
          
            # Block privileged roles from OAuth access
            blocked_roles_list = [
              "ACCOUNTADMIN",
              "SECURITYADMIN",
              "ORGADMIN",
            ]
          
            enabled = true
            }
          
            # External OAuth integration (L2) for IdP-issued tokens
            resource "snowflake_security_integration" "external_oauth" {
            count = var.profile_level >= 2 ? 1 : 0
          
            name    = "HTH_EXTERNAL_OAUTH"
            type    = "EXTERNAL_OAUTH"
            comment = "HTH: External OAuth with IdP-issued tokens (Control 3.2)"
          
            external_oauth_type               = var.external_oauth_type
            external_oauth_issuer             = var.external_oauth_issuer
            external_oauth_token_user_mapping_claim = ["sub"]
            external_oauth_snowflake_user_mapping_attribute = "login_name"
            external_oauth_jws_keys_url       = var.external_oauth_jws_keys_url
          
            blocked_roles_list = [
              "ACCOUNTADMIN",
              "SECURITYADMIN",
              "ORGADMIN",
            ]
          
            enabled = true
            }
  api:
    lang: "bash"
    filename: "hth-snowflake-3.01-restrict-oauth-scopes.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/api/hth-snowflake-3.01-restrict-oauth-scopes.sh"
    excerpts:
      audit-security-integrations:
        content: |
            # Audit all security integrations for OAuth scope and lifetime
            info "3.1 Auditing security integrations..."
            INTEGRATIONS=$(snow_query "SHOW SECURITY INTEGRATIONS;") || {
            warn "3.1 No security integrations found or query failed"
            INTEGRATIONS="[]"
            }
          
            OAUTH_COUNT=$(echo "${INTEGRATIONS}" | jq '[.[] | select(.type == "OAUTH - SNOWFLAKE" or .type == "OAUTH - CUSTOM" or .type == "OAUTH - EXTERNAL")] | length' 2>/dev/null || echo "0")
          
            if [ "${OAUTH_COUNT}" -gt 0 ]; then
            info "3.1 Found ${OAUTH_COUNT} OAuth integration(s):"
            echo "${INTEGRATIONS}" | jq -r '.[] | select(.type | test("OAUTH")) | "  - \(.name) [\(.type)] enabled=\(.enabled)"' 2>/dev/null || true
            else
            info "3.1 No OAuth integrations found"
            fi
      check-blocked-roles:
        content: |
            # Verify all OAuth integrations block privileged roles
            info "3.1 Checking OAuth integrations for blocked role lists..."
            INTEGRATION_NAMES=$(echo "${INTEGRATIONS}" | jq -r '.[] | select(.type | test("OAUTH")) | .name' 2>/dev/null || true)
          
            ISSUES_FOUND=0
            while IFS= read -r int_name; do
            [ -z "${int_name}" ] && continue
            DETAIL=$(snow_query "DESCRIBE SECURITY INTEGRATION \"${int_name}\";") || {
              warn "3.1 Could not describe integration: ${int_name}"
              continue
            }
          
            # Check for BLOCKED_ROLES_LIST
            BLOCKED=$(echo "${DETAIL}" | jq -r '.[] | select(.property == "BLOCKED_ROLES_LIST") | .property_value' 2>/dev/null || echo "")
          
            if [ -z "${BLOCKED}" ] || [ "${BLOCKED}" = "ACCOUNTADMIN, SECURITYADMIN" ]; then
              # Default -- check it at minimum blocks ACCOUNTADMIN
              if echo "${BLOCKED}" | grep -q "ACCOUNTADMIN"; then
                pass "3.1 Integration ${int_name} blocks ACCOUNTADMIN"
              else
                fail "3.1 Integration ${int_name} does NOT block ACCOUNTADMIN"
                ISSUES_FOUND=$((ISSUES_FOUND + 1))
              fi
            else
              info "3.1 Integration ${int_name} blocked roles: ${BLOCKED}"
            fi
          
            # Check token lifetime
            TOKEN_LIFETIME=$(echo "${DETAIL}" | jq -r '.[] | select(.property == "OAUTH_ACCESS_TOKEN_VALIDITY") | .property_value' 2>/dev/null || echo "")
            REFRESH_LIFETIME=$(echo "${DETAIL}" | jq -r '.[] | select(.property == "OAUTH_REFRESH_TOKEN_VALIDITY") | .property_value' 2>/dev/null || echo "")
          
            if [ -n "${TOKEN_LIFETIME}" ]; then
              if [ "${TOKEN_LIFETIME}" -le 600 ]; then
                pass "3.1 Integration ${int_name} access token lifetime: ${TOKEN_LIFETIME}s (<=600s)"
              else
                warn "3.1 Integration ${int_name} access token lifetime: ${TOKEN_LIFETIME}s (recommend <=600s)"
              fi
            fi
            done <<< "${INTEGRATION_NAMES}"

"3.2":
  db:
    lang: "sql"
    filename: "hth-snowflake-3.02-configure-external-oauth.sql"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/db/hth-snowflake-3.02-configure-external-oauth.sql"
    excerpts:
      db-configure-external-oauth:
        content: |
            -- Create External OAuth integration with Okta
            CREATE OR REPLACE SECURITY INTEGRATION okta_oauth
              TYPE = EXTERNAL_OAUTH
              ENABLED = TRUE
              EXTERNAL_OAUTH_TYPE = OKTA
              EXTERNAL_OAUTH_ISSUER = 'https://your-org.okta.com/oauth2/default'
              EXTERNAL_OAUTH_JWS_KEYS_URL = 'https://your-org.okta.com/oauth2/default/v1/keys'
              EXTERNAL_OAUTH_AUDIENCE_LIST = ('your-snowflake-account')
              EXTERNAL_OAUTH_TOKEN_USER_MAPPING_CLAIM = 'sub'
              EXTERNAL_OAUTH_SNOWFLAKE_USER_MAPPING_ATTRIBUTE = 'LOGIN_NAME';
          
            -- For Azure AD
            CREATE OR REPLACE SECURITY INTEGRATION azure_ad_oauth
              TYPE = EXTERNAL_OAUTH
              ENABLED = TRUE
              EXTERNAL_OAUTH_TYPE = AZURE
              EXTERNAL_OAUTH_ISSUER = 'https://login.microsoftonline.com/{tenant-id}/v2.0'
              EXTERNAL_OAUTH_JWS_KEYS_URL = 'https://login.microsoftonline.com/{tenant-id}/discovery/v2.0/keys'
              EXTERNAL_OAUTH_AUDIENCE_LIST = ('your-snowflake-account');

"4.1":
  terraform:
    lang: "hcl"
    filename: "hth-snowflake-4.01-column-masking.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/terraform/hth-snowflake-4.01-column-masking.tf"
    excerpts:
      terraform:
        content: |
            # Dynamic data masking policy for email addresses
            resource "snowflake_masking_policy" "mask_email" {
            count = var.profile_level >= 2 ? 1 : 0
          
            name     = "HTH_MASK_EMAIL"
            database = var.target_database
            schema   = var.target_schema
            comment  = "HTH: Mask email addresses for non-privileged roles (Control 4.1)"
          
            signature {
              column {
                name = "val"
                type = "VARCHAR"
              }
            }
          
            masking_expression = <<-EOT
              CASE
                WHEN CURRENT_ROLE() IN ('HTH_DATA_WRITER', 'SYSADMIN', 'ACCOUNTADMIN')
                  THEN val
                WHEN CURRENT_ROLE() = 'HTH_DATA_ANALYST'
                  THEN REGEXP_REPLACE(val, '.+@', '***@')
                ELSE '********'
              END
            EOT
          
            return_data_type = "VARCHAR"
            }
          
            # Dynamic data masking policy for SSN / national ID
            resource "snowflake_masking_policy" "mask_ssn" {
            count = var.profile_level >= 2 ? 1 : 0
          
            name     = "HTH_MASK_SSN"
            database = var.target_database
            schema   = var.target_schema
            comment  = "HTH: Mask SSN/national ID for non-privileged roles (Control 4.1)"
          
            signature {
              column {
                name = "val"
                type = "VARCHAR"
              }
            }
          
            masking_expression = <<-EOT
              CASE
                WHEN CURRENT_ROLE() IN ('SYSADMIN', 'ACCOUNTADMIN')
                  THEN val
                ELSE CONCAT('***-**-', RIGHT(val, 4))
              END
            EOT
          
            return_data_type = "VARCHAR"
            }
          
            # Row access policy for multi-tenant data isolation
            resource "snowflake_row_access_policy" "tenant_isolation" {
            count = var.profile_level >= 2 ? 1 : 0
          
            name     = "HTH_TENANT_ISOLATION"
            database = var.target_database
            schema   = var.target_schema
            comment  = "HTH: Row-level security for multi-tenant data isolation (Control 4.2)"
          
            signature {
              column {
                name = "tenant_id"
                type = "VARCHAR"
              }
            }
          
            row_access_expression = <<-EOT
              CASE
                WHEN CURRENT_ROLE() IN ('SYSADMIN', 'ACCOUNTADMIN')
                  THEN TRUE
                ELSE tenant_id = CURRENT_SESSION_CONTEXT('TENANT_ID')
              END
            EOT
            }

"4.2":
  db:
    lang: "sql"
    filename: "hth-snowflake-4.02-row-access-policy.sql"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/db/hth-snowflake-4.02-row-access-policy.sql"
    excerpts:
      db-row-access-policy:
        content: |
            -- Create row access policy
            CREATE OR REPLACE ROW ACCESS POLICY region_access AS (region_col VARCHAR)
            RETURNS BOOLEAN ->
              CURRENT_ROLE() IN ('DATA_ADMIN')
              OR region_col = CURRENT_SESSION()::JSON:region;
          
            -- Apply to table
            ALTER TABLE sales ADD ROW ACCESS POLICY region_access ON (region);

"5.1":
  api:
    lang: "bash"
    filename: "hth-snowflake-5.01-enable-audit-logging.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/api/hth-snowflake-5.01-enable-audit-logging.sh"
    excerpts:
      audit-login-history:
        content: |
            # Query recent login history for anomalies
            info "5.1 Querying login history (last 24 hours)..."
            LOGIN_HISTORY=$(snow_query "
            SELECT
              user_name,
              client_ip,
              reported_client_type,
              first_authentication_factor,
              second_authentication_factor,
              is_success,
              error_code,
              error_message,
              event_timestamp
            FROM SNOWFLAKE.ACCOUNT_USAGE.LOGIN_HISTORY
            WHERE event_timestamp > DATEADD('hour', -24, CURRENT_TIMESTAMP())
            ORDER BY event_timestamp DESC
            LIMIT 500;
            ") || {
            fail "5.1 Failed to query login history (check ACCOUNTADMIN or SNOWFLAKE database access)"
            increment_failed
            summary
            exit 0
            }
          
            TOTAL_LOGINS=$(echo "${LOGIN_HISTORY}" | jq 'length' 2>/dev/null || echo "0")
            FAILED_LOGINS=$(echo "${LOGIN_HISTORY}" | jq '[.[] | select(.IS_SUCCESS == "NO")] | length' 2>/dev/null || echo "0")
          
            info "5.1 Last 24h: ${TOTAL_LOGINS} total logins, ${FAILED_LOGINS} failed"
          
            if [ "${FAILED_LOGINS}" -gt 0 ]; then
            warn "5.1 Failed login attempts detected:"
            echo "${LOGIN_HISTORY}" | jq -r '.[] | select(.IS_SUCCESS == "NO") | "  - \(.USER_NAME) from \(.CLIENT_IP) [\(.REPORTED_CLIENT_TYPE)] error: \(.ERROR_MESSAGE)"' 2>/dev/null | head -20 || true
            fi
      detect-anomalies:
        content: |
            # Detect suspicious patterns: off-hours access, unusual clients, brute force
            info "5.1 Checking for brute-force patterns..."
            BRUTE_FORCE=$(snow_query "
            SELECT
              user_name,
              client_ip,
              COUNT(*) AS failed_attempts
            FROM SNOWFLAKE.ACCOUNT_USAGE.LOGIN_HISTORY
            WHERE event_timestamp > DATEADD('hour', -1, CURRENT_TIMESTAMP())
            AND is_success = 'NO'
            GROUP BY user_name, client_ip
            HAVING COUNT(*) >= 5
            ORDER BY failed_attempts DESC;
            ") || {
            warn "5.1 Could not run brute-force detection query"
            BRUTE_FORCE="[]"
            }
          
            BRUTE_COUNT=$(echo "${BRUTE_FORCE}" | jq 'length' 2>/dev/null || echo "0")
            if [ "${BRUTE_COUNT}" -gt 0 ]; then
            fail "5.1 Potential brute-force detected (>=5 failures/hour):"
            echo "${BRUTE_FORCE}" | jq -r '.[] | "  - \(.USER_NAME) from \(.CLIENT_IP): \(.FAILED_ATTEMPTS) attempts"' 2>/dev/null || true
            else
            pass "5.1 No brute-force patterns detected in the last hour"
            fi
          
            # Check for access without MFA
            info "5.1 Checking for logins without second factor..."
            NO_MFA_LOGINS=$(snow_query "
            SELECT
              user_name,
              client_ip,
              first_authentication_factor,
              second_authentication_factor,
              COUNT(*) AS login_count
            FROM SNOWFLAKE.ACCOUNT_USAGE.LOGIN_HISTORY
            WHERE event_timestamp > DATEADD('hour', -24, CURRENT_TIMESTAMP())
            AND is_success = 'YES'
            AND (second_authentication_factor IS NULL OR second_authentication_factor = '')
            GROUP BY user_name, client_ip, first_authentication_factor, second_authentication_factor
            ORDER BY login_count DESC;
            ") || {
            warn "5.1 Could not query MFA login data"
            NO_MFA_LOGINS="[]"
            }
          
            NO_MFA_COUNT=$(echo "${NO_MFA_LOGINS}" | jq 'length' 2>/dev/null || echo "0")
            if [ "${NO_MFA_COUNT}" -gt 0 ]; then
            warn "5.1 ${NO_MFA_COUNT} user(s) logged in without second factor in last 24h"
            echo "${NO_MFA_LOGINS}" | jq -r '.[] | "  - \(.USER_NAME) via \(.FIRST_AUTHENTICATION_FACTOR) (\(.LOGIN_COUNT)x)"' 2>/dev/null | head -10 || true
            else
            pass "5.1 All successful logins used a second authentication factor"
            fi
      verify-account-usage:
        content: |
            # Verify ACCOUNT_USAGE schema is accessible (required for audit)
            info "5.1 Verifying ACCOUNT_USAGE schema access..."
            snow_query "SELECT COUNT(*) AS cnt FROM SNOWFLAKE.ACCOUNT_USAGE.QUERY_HISTORY WHERE start_time > DATEADD('minute', -5, CURRENT_TIMESTAMP());" > /dev/null 2>&1 && {
            pass "5.1 ACCOUNT_USAGE schema is accessible for audit logging"
            } || {
            fail "5.1 Cannot access ACCOUNT_USAGE schema -- grant IMPORTED PRIVILEGES on SNOWFLAKE database"
            }
  sigma:
    - lang: "yaml"
      filename: "hth-snowflake-5.01-bulk-data-export.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/siem/sigma/hth-snowflake-5.01-bulk-data-export.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection_copy:
                    query_text|contains:
                        - 'COPY INTO @'
                        - 'COPY INTO ''s3://'
                        - 'COPY INTO ''gcs://'
                        - 'COPY INTO ''azure://'
                selection_large_result:
                    rows_produced|gte: 1000000
                selection_large_bytes:
                    bytes_scanned|gte: 1073741824
                filter_success:
                    execution_status: 'SUCCESS'
                condition: (selection_copy or selection_large_result or selection_large_bytes) and filter_success
              fields:
                - user_name
                - role_name
                - query_text
                - rows_produced
                - bytes_scanned
                - start_time
                - warehouse_name
                - client_ip

"5.2":
  db:
    lang: "sql"
    filename: "hth-snowflake-5.02-siem-export-task.sql"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/db/hth-snowflake-5.02-siem-export-task.sql"
    excerpts:
      db-siem-export-task:
        content: |
            -- Create task to export logs to S3/Azure Blob for SIEM ingestion
            CREATE OR REPLACE TASK export_login_history
              WAREHOUSE = security_wh
              SCHEDULE = '60 MINUTE'
            AS
              COPY INTO @security_logs/login_history/
              FROM (
                  SELECT *
                  FROM SNOWFLAKE.ACCOUNT_USAGE.LOGIN_HISTORY
                  WHERE event_timestamp > DATEADD(minute, -60, CURRENT_TIMESTAMP())
              )
              FILE_FORMAT = (TYPE = JSON);
          
            ALTER TASK export_login_history RESUME;

"6.2":
  db:
    lang: "sql"
    filename: "hth-snowflake-6.02-tableau-integration.sql"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/snowflake/db/hth-snowflake-6.02-tableau-integration.sql"
    excerpts:
      db-tableau-integration:
        content: |
            -- Create restricted role for Tableau
            CREATE ROLE tableau_reader;
            GRANT USAGE ON WAREHOUSE bi_warehouse TO ROLE tableau_reader;
            GRANT USAGE ON DATABASE analytics TO ROLE tableau_reader;
            GRANT USAGE ON ALL SCHEMAS IN DATABASE analytics TO ROLE tableau_reader;
            GRANT SELECT ON ALL TABLES IN SCHEMA analytics.dashboards TO ROLE tableau_reader;
          
            -- Create service account
            CREATE USER svc_tableau
              DEFAULT_ROLE = tableau_reader
              DEFAULT_WAREHOUSE = bi_warehouse
              RSA_PUBLIC_KEY = 'MIIBIjAN...';
          
            -- Apply network policy
            ALTER USER svc_tableau SET NETWORK_POLICY = tableau_only;

