# AUTO-GENERATED by scripts/sync-packs-to-data.sh — do not edit manually
# Generated: 2026-02-19T00:06:09Z

"1.1":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-1.01-configure-identity-provider.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-1.01-configure-identity-provider.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_access_identity_provider" "corporate_idp" {
            account_id = var.cloudflare_account_id
            name       = "Corporate IdP"
            type       = "oidc"
          
            config = {
              client_id     = var.oidc_client_id
              client_secret = var.oidc_client_secret
              auth_url      = var.oidc_auth_url
              token_url     = var.oidc_token_url
              certs_url     = var.oidc_certs_url
              claims        = ["email_verified", "preferred_username", "groups"]
              scopes        = ["openid", "email", "profile", "groups"]
            }
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-1.01-configure-identity-provider.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-1.01-configure-identity-provider.sh"
    excerpts:
      api-add-idp:
        content: |
            # Add OIDC identity provider to Zero Trust
            info "1.1 Adding OIDC identity provider..."
            : "${CF_IDP_CLIENT_ID:?Set CF_IDP_CLIENT_ID}"
            : "${CF_IDP_CLIENT_SECRET:?Set CF_IDP_CLIENT_SECRET}"
            : "${CF_IDP_AUTH_URL:?Set CF_IDP_AUTH_URL}"
            : "${CF_IDP_TOKEN_URL:?Set CF_IDP_TOKEN_URL}"
          
            RESPONSE=$(cf_post "/accounts/${CF_ACCOUNT_ID}/access/identity_providers" "{
            \"name\": \"Corporate IdP\",
            \"type\": \"oidc\",
            \"config\": {
              \"client_id\": \"${CF_IDP_CLIENT_ID}\",
              \"client_secret\": \"${CF_IDP_CLIENT_SECRET}\",
              \"auth_url\": \"${CF_IDP_AUTH_URL}\",
              \"token_url\": \"${CF_IDP_TOKEN_URL}\",
              \"claims\": [\"email_verified\", \"preferred_username\", \"groups\"],
              \"scopes\": [\"openid\", \"email\", \"profile\", \"groups\"]
            }
            }") || {
            fail "1.1 Failed to add identity provider"
            increment_failed
            summary
            exit 0
            }
  sigma:
    - lang: "yaml"
      filename: "hth-cloudflare-1.01-configure-identity-provider.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/siem/sigma/hth-cloudflare-1.01-configure-identity-provider.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    ActionType|contains:
                        - 'DeleteAccessIdentityProvider'
                        - 'UpdateAccessIdentityProvider'
                condition: selection
              fields:
                - ActorEmail
                - ActionType
                - ResourceID
                - When

"1.2":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-1.02-configure-mfa.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-1.02-configure-mfa.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_access_policy" "require_mfa" {
            account_id = var.cloudflare_account_id
            name       = "Require MFA for all users"
            decision   = "allow"
          
            include = [{
              email_domain = {
                domain = var.corporate_domain
              }
            }]
          
            require = [{
              auth_method = {
                auth_method = "mfa"
              }
            }]
          
            session_duration = "24h"
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-1.02-configure-mfa.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-1.02-configure-mfa.sh"
    excerpts:
      api-verify-mfa:
        content: |
            # Verify MFA is required in Access policies
            # MFA enforcement is set via Access policy 'require' rules
            # Check each app for auth_method = mfa in require blocks
            MFA_MISSING=0
            while IFS= read -r app_id; do
            APP_POLICIES=$(cf_get "/accounts/${CF_ACCOUNT_ID}/access/apps/${app_id}/policies") || continue
            HAS_MFA=$(echo "${APP_POLICIES}" | jq '[.result[].require[]? | select(.auth_method.auth_method == "mfa")] | length')
            if [ "${HAS_MFA}" = "0" ]; then
              APP_NAME=$(echo "${POLICIES}" | jq -r ".result[] | select(.id == \"${app_id}\") | .name")
              warn "1.2 Application '${APP_NAME}' does not require MFA"
              MFA_MISSING=$((MFA_MISSING + 1))
            fi
            done < <(echo "${POLICIES}" | jq -r '.result[].id')

"1.3":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-1.03-harden-device-enrollment.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-1.03-harden-device-enrollment.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_access_application" "warp_enrollment" {
            account_id       = var.cloudflare_account_id
            name             = "Device Enrollment"
            type             = "warp"
            session_duration = "24h"
          
            allowed_idps              = [cloudflare_zero_trust_access_identity_provider.corporate_idp.id]
            auto_redirect_to_identity = true
            }
          
            resource "cloudflare_zero_trust_access_policy" "device_enrollment_policy" {
            account_id = var.cloudflare_account_id
            name       = "Restrict device enrollment to corporate users"
            decision   = "allow"
          
            include = [{
              email_domain = {
                domain = var.corporate_domain
              }
            }]
          
            require = [{
              auth_method = {
                auth_method = "mfa"
              }
            }]
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-1.03-harden-device-enrollment.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-1.03-harden-device-enrollment.sh"
    excerpts:
      api-check-enrollment:
        content: |
            # Check device enrollment permissions
            ENROLLMENT=$(cf_get "/accounts/${CF_ACCOUNT_ID}/devices/policy") || {
            fail "1.3 Unable to retrieve device enrollment policy"
            increment_failed
            summary
            exit 0
            }
          
            # Verify enrollment requires authentication
            REQUIRE_AUTH=$(echo "${ENROLLMENT}" | jq -r '.result.allow_mode_switch // false')
            info "1.3 Device policy retrieved -- reviewing enrollment settings"
          
            # List enrollment rules
            RULES=$(cf_get "/accounts/${CF_ACCOUNT_ID}/devices/policy/include") 2>/dev/null || true
            EXCLUDE=$(cf_get "/accounts/${CF_ACCOUNT_ID}/devices/policy/exclude") 2>/dev/null || true

"1.4":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-1.04-configure-admin-roles.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-1.04-configure-admin-roles.tf"
    excerpts:
      terraform:
        content: |
            data "cloudflare_account_roles" "all" {
            account_id = var.cloudflare_account_id
            }
          
            locals {
            roles_by_name = {
              for role in data.cloudflare_account_roles.all.result :
              role.name => role
            }
            }
          
            resource "cloudflare_account_member" "zt_admin" {
            account_id = var.cloudflare_account_id
            email      = var.zt_admin_email
            roles      = [local.roles_by_name["Administrator"].id]
            }
          
            resource "cloudflare_account_member" "audit_viewer" {
            account_id = var.cloudflare_account_id
            email      = var.audit_viewer_email
            roles      = [local.roles_by_name["Administrator Read Only"].id]
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-1.04-configure-admin-roles.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-1.04-configure-admin-roles.sh"
    excerpts:
      api-audit-roles:
        content: |
            # List all account members and their roles
            MEMBERS=$(cf_get "/accounts/${CF_ACCOUNT_ID}/members?per_page=50") || {
            fail "1.4 Unable to retrieve account members"
            increment_failed
            summary
            exit 0
            }
          
            MEMBER_COUNT=$(echo "${MEMBERS}" | jq '.result | length')
            info "1.4 Found ${MEMBER_COUNT} account member(s)"
          
            # Check for Super Administrator count
            SUPER_ADMINS=$(echo "${MEMBERS}" | jq '[.result[] | select(.roles[]?.name == "Super Administrator")] | length')
            if [ "${SUPER_ADMINS}" -gt 3 ]; then
            warn "1.4 ${SUPER_ADMINS} Super Administrators found (recommend max 2-3)"
            else
            pass "1.4 ${SUPER_ADMINS} Super Administrator(s) found (within recommended limit)"
            fi
          
            # List all members with their roles
            echo "${MEMBERS}" | jq -r '.result[] | "  - \(.user.email): \([.roles[].name] | join(", "))"'
  sigma:
    - lang: "yaml"
      filename: "hth-cloudflare-1.04-configure-admin-roles.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/siem/sigma/hth-cloudflare-1.04-configure-admin-roles.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    ActionType: 'UpdateMember'
                filter_role:
                    ActionMetadata|contains: 'Super Administrator'
                condition: selection and filter_role
              fields:
                - ActorEmail
                - ActionType
                - ResourceID
                - When

"2.1":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-2.01-create-access-policies.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-2.01-create-access-policies.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_access_group" "employees" {
            account_id = var.cloudflare_account_id
            name       = "All Employees"
          
            include = [{
              email_domain = {
                domain = var.corporate_domain
              }
            }]
            }
          
            resource "cloudflare_zero_trust_access_application" "internal_app" {
            zone_id          = var.cloudflare_zone_id
            name             = "Internal Application"
            domain           = var.app_domain
            type             = "self_hosted"
            session_duration = "8h"
          
            allowed_idps              = [cloudflare_zero_trust_access_identity_provider.corporate_idp.id]
            auto_redirect_to_identity = true
            }
          
            resource "cloudflare_zero_trust_access_policy" "allow_employees" {
            account_id = var.cloudflare_account_id
            name       = "Allow authenticated employees"
            decision   = "allow"
          
            include = [{
              group = {
                id = cloudflare_zero_trust_access_group.employees.id
              }
            }]
          
            require = [{
              auth_method = {
                auth_method = "mfa"
              }
            }]
          
            session_duration = "8h"
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-2.01-create-access-policies.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-2.01-create-access-policies.sh"
    excerpts:
      api-audit-access-apps:
        content: |
            # List all Access applications and check policy configuration
            APPS=$(cf_get "/accounts/${CF_ACCOUNT_ID}/access/apps") || {
            fail "2.1 Unable to retrieve Access applications"
            increment_failed
            summary
            exit 0
            }
          
            APP_COUNT=$(echo "${APPS}" | jq '.result | length')
            info "2.1 Found ${APP_COUNT} Access application(s)"
          
            UNPROTECTED=0
            while IFS= read -r app_line; do
            APP_ID=$(echo "${app_line}" | jq -r '.id')
            APP_NAME=$(echo "${app_line}" | jq -r '.name')
            APP_DOMAIN=$(echo "${app_line}" | jq -r '.domain // "N/A"')
          
            POLICIES=$(cf_get "/accounts/${CF_ACCOUNT_ID}/access/apps/${APP_ID}/policies") || continue
            POLICY_COUNT=$(echo "${POLICIES}" | jq '.result | length')
          
            if [ "${POLICY_COUNT}" = "0" ]; then
              warn "2.1 Application '${APP_NAME}' (${APP_DOMAIN}) has NO Access policies"
              UNPROTECTED=$((UNPROTECTED + 1))
            else
              pass "2.1 Application '${APP_NAME}' has ${POLICY_COUNT} policy(s)"
            fi
            done < <(echo "${APPS}" | jq -c '.result[]')
  sigma:
    - lang: "yaml"
      filename: "hth-cloudflare-2.01-create-access-policies.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/siem/sigma/hth-cloudflare-2.01-create-access-policies.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    ActionType|contains:
                        - 'DeleteAccessPolicy'
                        - 'DeleteAccessApplication'
                condition: selection
              fields:
                - ActorEmail
                - ActionType
                - ResourceID
                - When

"2.2":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-2.02-require-warp.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-2.02-require-warp.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_device_posture_rule" "warp_connected" {
            account_id  = var.cloudflare_account_id
            name        = "Require WARP Connected"
            type        = "warp"
            description = "Ensure device is running WARP client"
          
            match = [{
              platform = "windows"
            }, {
              platform = "mac"
            }, {
              platform = "linux"
            }]
            }
          
            resource "cloudflare_zero_trust_access_policy" "require_warp" {
            account_id = var.cloudflare_account_id
            name       = "Require WARP for application access"
            decision   = "allow"
          
            include = [{
              email_domain = {
                domain = var.corporate_domain
              }
            }]
          
            require = [{
              device_posture = {
                integration_uid = cloudflare_zero_trust_device_posture_rule.warp_connected.id
              }
            }]
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-2.02-require-warp.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-2.02-require-warp.sh"
    excerpts:
      api-check-warp-posture:
        content: |
            # Check for a WARP device posture rule
            POSTURE_RULES=$(cf_get "/accounts/${CF_ACCOUNT_ID}/devices/posture") || {
            fail "2.2 Unable to retrieve device posture rules"
            increment_failed
            summary
            exit 0
            }
          
            WARP_RULES=$(echo "${POSTURE_RULES}" | jq '[.result[] | select(.type == "warp")] | length')
          
            if [ "${WARP_RULES}" -gt 0 ]; then
            pass "2.2 WARP device posture rule exists (${WARP_RULES} rule(s))"
            echo "${POSTURE_RULES}" | jq -r '.result[] | select(.type == "warp") | "  - \(.name): \(.type)"'
            else
            warn "2.2 No WARP device posture rule found -- create one to require WARP for app access"
            fi

"2.3":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-2.03-configure-device-posture.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-2.03-configure-device-posture.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_device_posture_rule" "disk_encryption" {
            account_id  = var.cloudflare_account_id
            name        = "Require Disk Encryption"
            type        = "disk_encryption"
            description = "Ensure full-disk encryption is enabled (FileVault/BitLocker)"
            schedule    = "1h"
          
            input = {
              require_all = true
            }
          
            match = [{
              platform = "windows"
            }, {
              platform = "mac"
            }]
            }
          
            resource "cloudflare_zero_trust_device_posture_rule" "firewall_enabled" {
            account_id  = var.cloudflare_account_id
            name        = "Require Firewall Enabled"
            type        = "firewall"
            description = "Ensure host firewall is enabled"
            schedule    = "1h"
          
            match = [{
              platform = "windows"
            }, {
              platform = "mac"
            }]
            }
          
            resource "cloudflare_zero_trust_device_posture_rule" "os_version" {
            account_id  = var.cloudflare_account_id
            name        = "Minimum OS Version"
            type        = "os_version"
            description = "Require minimum OS version"
            schedule    = "24h"
          
            input = {
              version  = var.min_os_version
              operator = ">="
            }
          
            match = [{
              platform = "mac"
            }]
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-2.03-configure-device-posture.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-2.03-configure-device-posture.sh"
    excerpts:
      api-audit-posture:
        content: |
            # List all device posture rules
            POSTURE_RULES=$(cf_get "/accounts/${CF_ACCOUNT_ID}/devices/posture") || {
            fail "2.3 Unable to retrieve device posture rules"
            increment_failed
            summary
            exit 0
            }
          
            RULE_COUNT=$(echo "${POSTURE_RULES}" | jq '.result | length')
            info "2.3 Found ${RULE_COUNT} device posture rule(s)"
          
            # Check for recommended posture checks
            HAS_DISK=$(echo "${POSTURE_RULES}" | jq '[.result[] | select(.type == "disk_encryption")] | length')
            HAS_FW=$(echo "${POSTURE_RULES}" | jq '[.result[] | select(.type == "firewall")] | length')
            HAS_OS=$(echo "${POSTURE_RULES}" | jq '[.result[] | select(.type == "os_version")] | length')
          
            [ "${HAS_DISK}" -gt 0 ] && pass "2.3 Disk encryption check configured" || warn "2.3 No disk encryption posture check found"
            [ "${HAS_FW}" -gt 0 ]   && pass "2.3 Firewall check configured"        || warn "2.3 No firewall posture check found"
            [ "${HAS_OS}" -gt 0 ]   && pass "2.3 OS version check configured"       || warn "2.3 No OS version posture check found"
          
            echo "${POSTURE_RULES}" | jq -r '.result[] | "  - \(.name) (\(.type))"'

"3.1":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-3.01-configure-dns-filtering.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-3.01-configure-dns-filtering.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_gateway_policy" "block_security_threats_dns" {
            account_id = var.cloudflare_account_id
            name       = "Block Security Threats (DNS)"
            action     = "block"
            filters    = ["dns"]
            traffic    = "any(dns.security_category[*] in {80 83 176 178})"
            enabled    = true
            precedence = 10
          
            rule_settings = {
              block_page_enabled = true
              block_reason       = "Blocked: malware, phishing, spyware, or C2 domain"
            }
            }
          
            resource "cloudflare_zero_trust_gateway_policy" "block_content_categories_dns" {
            account_id = var.cloudflare_account_id
            name       = "Block Restricted Content Categories (DNS)"
            action     = "block"
            filters    = ["dns"]
            traffic    = "any(dns.content_category[*] in {133 134 135 136})"
            enabled    = true
            precedence = 20
          
            rule_settings = {
              block_page_enabled = true
              block_reason       = "This content category is blocked by policy"
            }
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-3.01-configure-dns-filtering.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-3.01-configure-dns-filtering.sh"
    excerpts:
      api-create-dns-policy:
        content: |
            # Create Gateway DNS policy to block security threats
            EXISTING=$(cf_get "/accounts/${CF_ACCOUNT_ID}/gateway/rules") || {
            fail "3.1 Unable to retrieve Gateway rules"
            increment_failed
            summary
            exit 0
            }
          
            DNS_BLOCK_RULES=$(echo "${EXISTING}" | jq '[.result[] | select(.filters == ["dns"] and .action == "block")] | length')
          
            if [ "${DNS_BLOCK_RULES}" -gt 0 ]; then
            pass "3.1 Found ${DNS_BLOCK_RULES} DNS blocking rule(s) already configured"
            echo "${EXISTING}" | jq -r '.result[] | select(.filters == ["dns"] and .action == "block") | "  - \(.name)"'
            increment_applied
            summary
            exit 0
            fi
          
            info "3.1 Creating DNS security threat blocking rule..."
            RESPONSE=$(cf_post "/accounts/${CF_ACCOUNT_ID}/gateway/rules" '{
            "name": "HTH: Block Security Threats (DNS)",
            "action": "block",
            "filters": ["dns"],
            "traffic": "any(dns.security_category[*] in {80 83 176 178})",
            "enabled": true,
            "precedence": 10,
            "rule_settings": {
              "block_page_enabled": true,
              "block_reason": "Blocked: malware, phishing, spyware, or C2 domain"
            }
            }') || {
            fail "3.1 Failed to create DNS blocking rule"
            increment_failed
            summary
            exit 0
            }
  sigma:
    - lang: "yaml"
      filename: "hth-cloudflare-3.01-configure-dns-filtering.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/siem/sigma/hth-cloudflare-3.01-configure-dns-filtering.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    ActionType|contains:
                        - 'DeleteGatewayRule'
                        - 'UpdateGatewayRule'
                filter_dns:
                    ActionMetadata|contains: 'dns'
                condition: selection and filter_dns
              fields:
                - ActorEmail
                - ActionType
                - ResourceID
                - When

"3.2":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-3.02-configure-http-filtering.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-3.02-configure-http-filtering.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_gateway_policy" "block_malware_http" {
            account_id = var.cloudflare_account_id
            name       = "Block Malware Downloads (HTTP)"
            action     = "block"
            filters    = ["http"]
            traffic    = "any(http.request.uri.content_category[*] in {80 83})"
            enabled    = true
            precedence = 10
          
            rule_settings = {
              block_page_enabled = true
              block_reason       = "Blocked: malware risk detected in download"
            }
            }
          
            resource "cloudflare_zero_trust_gateway_policy" "av_scan_downloads" {
            account_id = var.cloudflare_account_id
            name       = "Scan file downloads for threats"
            action     = "block"
            filters    = ["http"]
            traffic    = "any(http.request.uri.content_category[*] in {80}) and http.request.method == \"GET\""
            enabled    = true
            precedence = 15
          
            rule_settings = {
              block_page_enabled = true
              block_reason       = "File blocked: threat detected during scan"
            }
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-3.02-configure-http-filtering.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-3.02-configure-http-filtering.sh"
    excerpts:
      api-create-http-policy:
        content: |
            # Create Gateway HTTP policy to block malware downloads
            EXISTING=$(cf_get "/accounts/${CF_ACCOUNT_ID}/gateway/rules") || {
            fail "3.2 Unable to retrieve Gateway rules"
            increment_failed
            summary
            exit 0
            }
          
            HTTP_BLOCK_RULES=$(echo "${EXISTING}" | jq '[.result[] | select(.filters == ["http"] and .action == "block")] | length')
          
            if [ "${HTTP_BLOCK_RULES}" -gt 0 ]; then
            pass "3.2 Found ${HTTP_BLOCK_RULES} HTTP blocking rule(s) already configured"
            increment_applied
            summary
            exit 0
            fi
          
            info "3.2 Creating HTTP malware download blocking rule..."
            RESPONSE=$(cf_post "/accounts/${CF_ACCOUNT_ID}/gateway/rules" '{
            "name": "HTH: Block Malware Downloads (HTTP)",
            "action": "block",
            "filters": ["http"],
            "traffic": "any(http.request.uri.content_category[*] in {80 83})",
            "enabled": true,
            "precedence": 10,
            "rule_settings": {
              "block_page_enabled": true,
              "block_reason": "Blocked: malware risk detected in download"
            }
            }') || {
            fail "3.2 Failed to create HTTP blocking rule"
            increment_failed
            summary
            exit 0
            }

"3.3":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-3.03-configure-network-policies.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-3.03-configure-network-policies.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_gateway_policy" "block_risky_protocols" {
            account_id = var.cloudflare_account_id
            name       = "Block SSH to external hosts"
            action     = "block"
            filters    = ["l4"]
            traffic    = "net.dst.port == 22 and net.dst.ip !in {10.0.0.0/8 172.16.0.0/12 192.168.0.0/16}"
            enabled    = true
            precedence = 10
            }
          
            resource "cloudflare_zero_trust_gateway_policy" "audit_rdp" {
            account_id = var.cloudflare_account_id
            name       = "Audit RDP connections"
            action     = "allow"
            filters    = ["l4"]
            traffic    = "net.dst.port == 3389"
            enabled    = true
            precedence = 20
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-3.03-configure-network-policies.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-3.03-configure-network-policies.sh"
    excerpts:
      api-create-network-policy:
        content: |
            # Create Gateway network policy to block risky protocols
            EXISTING=$(cf_get "/accounts/${CF_ACCOUNT_ID}/gateway/rules") || {
            fail "3.3 Unable to retrieve Gateway rules"
            increment_failed
            summary
            exit 0
            }
          
            L4_RULES=$(echo "${EXISTING}" | jq '[.result[] | select(.filters == ["l4"])] | length')
          
            if [ "${L4_RULES}" -gt 0 ]; then
            pass "3.3 Found ${L4_RULES} network (L4) rule(s) already configured"
            increment_applied
            summary
            exit 0
            fi
          
            info "3.3 Creating network policy to block external SSH..."
            RESPONSE=$(cf_post "/accounts/${CF_ACCOUNT_ID}/gateway/rules" '{
            "name": "HTH: Block External SSH",
            "action": "block",
            "filters": ["l4"],
            "traffic": "net.dst.port == 22 and net.dst.ip !in {10.0.0.0/8 172.16.0.0/12 192.168.0.0/16}",
            "enabled": true,
            "precedence": 10
            }') || {
            fail "3.3 Failed to create network blocking rule"
            increment_failed
            summary
            exit 0
            }

"3.4":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-3.04-enable-browser-isolation.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-3.04-enable-browser-isolation.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_gateway_policy" "isolate_risky_sites" {
            account_id = var.cloudflare_account_id
            name       = "Isolate risky and uncategorized websites"
            action     = "isolate"
            filters    = ["http"]
            traffic    = "any(http.request.uri.content_category[*] in {68 155})"
            enabled    = true
            precedence = 5
          
            rule_settings = {
              biso_admin_controls = {
                copy     = "remote_only"
                paste    = "block"
                download = "block"
                upload   = "block"
                printing = "block"
                keyboard = "allow"
              }
            }
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-3.04-enable-browser-isolation.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-3.04-enable-browser-isolation.sh"
    excerpts:
      api-create-isolation-policy:
        content: |
            # Create Gateway HTTP policy with isolate action for risky sites
            EXISTING=$(cf_get "/accounts/${CF_ACCOUNT_ID}/gateway/rules") || {
            fail "3.4 Unable to retrieve Gateway rules"
            increment_failed
            summary
            exit 0
            }
          
            ISOLATE_RULES=$(echo "${EXISTING}" | jq '[.result[] | select(.action == "isolate")] | length')
          
            if [ "${ISOLATE_RULES}" -gt 0 ]; then
            pass "3.4 Found ${ISOLATE_RULES} browser isolation rule(s) already configured"
            increment_applied
            summary
            exit 0
            fi
          
            info "3.4 Creating browser isolation policy for risky sites..."
            RESPONSE=$(cf_post "/accounts/${CF_ACCOUNT_ID}/gateway/rules" '{
            "name": "HTH: Isolate Risky Websites",
            "action": "isolate",
            "filters": ["http"],
            "traffic": "any(http.request.uri.content_category[*] in {68 155})",
            "enabled": true,
            "precedence": 5,
            "rule_settings": {
              "biso_admin_controls": {
                "dcp": true,
                "dd": true,
                "du": true,
                "dp": true,
                "dk": false
              }
            }
            }') || {
            fail "3.4 Failed to create browser isolation rule"
            increment_failed
            summary
            exit 0
            }

"4.1":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-4.01-configure-warp-settings.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-4.01-configure-warp-settings.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_device_default_profile" "default" {
            account_id        = var.cloudflare_account_id
            auto_connect      = 0
            captive_portal    = 180
            allow_mode_switch = false
            allow_updates     = true
            tunnel_protocol   = "wireguard"
          
            service_mode_v2 = {
              mode = "warp"
            }
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-4.01-configure-warp-settings.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-4.01-configure-warp-settings.sh"
    excerpts:
      api-configure-warp:
        content: |
            # Configure default WARP device settings
            CURRENT=$(cf_get "/accounts/${CF_ACCOUNT_ID}/devices/policy") || {
            fail "4.1 Unable to retrieve device policy"
            increment_failed
            summary
            exit 0
            }
          
            info "4.1 Current device policy settings:"
            echo "${CURRENT}" | jq '.result | {
            auto_connect: .auto_connect,
            captive_portal: .captive_portal,
            allow_mode_switch: .allow_mode_switch,
            switch_locked: .switch_locked,
            tunnel_protocol: .tunnel_protocol
            }'
          
            # Apply hardened settings
            RESPONSE=$(cf_patch "/accounts/${CF_ACCOUNT_ID}/devices/policy" '{
            "auto_connect": 0,
            "captive_portal": 180,
            "allow_mode_switch": false,
            "tunnel_protocol": "wireguard"
            }') || {
            fail "4.1 Failed to update device policy"
            increment_failed
            summary
            exit 0
            }

"4.2":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-4.02-lock-warp-client.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-4.02-lock-warp-client.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_device_default_profile" "locked" {
            account_id        = var.cloudflare_account_id
            switch_locked     = true
            allowed_to_leave  = false
            allow_mode_switch = false
            auto_connect      = 0
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-4.02-lock-warp-client.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-4.02-lock-warp-client.sh"
    excerpts:
      api-lock-warp:
        content: |
            # Lock WARP client to prevent users from disabling
            info "4.2 Locking WARP client..."
            RESPONSE=$(cf_patch "/accounts/${CF_ACCOUNT_ID}/devices/policy" '{
            "switch_locked": true,
            "allowed_to_leave": false,
            "allow_mode_switch": false
            }') || {
            fail "4.2 Failed to lock WARP client"
            increment_failed
            summary
            exit 0
            }
  sigma:
    - lang: "yaml"
      filename: "hth-cloudflare-4.02-lock-warp-client.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/siem/sigma/hth-cloudflare-4.02-lock-warp-client.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    ActionType: 'UpdateDevicePolicy'
                filter_unlock:
                    ActionMetadata|contains:
                        - 'switch_locked'
                        - 'allowed_to_leave'
                condition: selection and filter_unlock
              fields:
                - ActorEmail
                - ActionType
                - ResourceID
                - When

"4.3":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-4.03-configure-split-tunnels.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-4.03-configure-split-tunnels.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_device_default_profile" "split_tunnel" {
            account_id    = var.cloudflare_account_id
            switch_locked = true
          
            exclude = [{
              address     = "10.0.0.0/8"
              description = "Internal RFC1918"
            }, {
              address     = "172.16.0.0/12"
              description = "Internal RFC1918"
            }, {
              address     = "192.168.0.0/16"
              description = "Internal RFC1918"
            }]
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-4.03-configure-split-tunnels.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-4.03-configure-split-tunnels.sh"
    excerpts:
      api-audit-split-tunnel:
        content: |
            # Audit split tunnel exclude list
            EXCLUDE_LIST=$(cf_get "/accounts/${CF_ACCOUNT_ID}/devices/policy/exclude") || {
            fail "4.3 Unable to retrieve split tunnel exclude list"
            increment_failed
            summary
            exit 0
            }
          
            EXCLUDE_COUNT=$(echo "${EXCLUDE_LIST}" | jq '.result | length')
            info "4.3 Found ${EXCLUDE_COUNT} split tunnel exclusion(s)"
          
            if [ "${EXCLUDE_COUNT}" -gt 20 ]; then
            warn "4.3 ${EXCLUDE_COUNT} exclusions is excessive -- review and minimize exceptions"
            else
            pass "4.3 Split tunnel exclusion count (${EXCLUDE_COUNT}) is within reasonable range"
            fi
          
            echo "${EXCLUDE_LIST}" | jq -r '.result[] | "  - \(.address // .host // "unknown"): \(.description // "no description")"'

"5.1":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-5.01-secure-tunnel-config.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-5.01-secure-tunnel-config.tf"
    excerpts:
      terraform:
        content: |
            resource "random_id" "tunnel_secret" {
            byte_length = 35
            }
          
            resource "cloudflare_zero_trust_tunnel_cloudflared" "app_tunnel" {
            account_id    = var.cloudflare_account_id
            name          = "app-tunnel"
            config_src    = "cloudflare"
            tunnel_secret = random_id.tunnel_secret.b64_std
            }
          
            resource "cloudflare_zero_trust_tunnel_cloudflared_config" "app_tunnel_config" {
            account_id = var.cloudflare_account_id
            tunnel_id  = cloudflare_zero_trust_tunnel_cloudflared.app_tunnel.id
          
            config = {
              ingress = [{
                hostname = var.app_domain
                service  = var.app_origin_url
          
                origin_request = {
                  connect_timeout = 10
                  no_tls_verify   = false
                }
              }, {
                service = "http_status:404"
              }]
            }
            }
          
            resource "cloudflare_dns_record" "tunnel_cname" {
            zone_id = var.cloudflare_zone_id
            name    = var.app_subdomain
            type    = "CNAME"
            content = "${cloudflare_zero_trust_tunnel_cloudflared.app_tunnel.id}.cfargotunnel.com"
            proxied = true
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-5.01-secure-tunnel-config.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-5.01-secure-tunnel-config.sh"
    excerpts:
      api-audit-tunnels:
        content: |
            # List all tunnels and check configuration
            TUNNELS=$(cf_get "/accounts/${CF_ACCOUNT_ID}/cfd_tunnel?is_deleted=false") || {
            fail "5.1 Unable to retrieve tunnel list"
            increment_failed
            summary
            exit 0
            }
          
            TUNNEL_COUNT=$(echo "${TUNNELS}" | jq '.result | length')
            info "5.1 Found ${TUNNEL_COUNT} active tunnel(s)"
          
            while IFS= read -r tunnel; do
            TUNNEL_ID=$(echo "${tunnel}" | jq -r '.id')
            TUNNEL_NAME=$(echo "${tunnel}" | jq -r '.name')
            TUNNEL_STATUS=$(echo "${tunnel}" | jq -r '.status')
            REMOTE_CONFIG=$(echo "${tunnel}" | jq -r '.remote_config // false')
          
            echo -e "  Tunnel: ${TUNNEL_NAME} (${TUNNEL_STATUS})"
            echo -e "  Config: $([ "${REMOTE_CONFIG}" = "true" ] && echo "dashboard-managed" || echo "local config")"
          
            # Check tunnel connections
            CONNS=$(echo "${tunnel}" | jq '.connections | length')
            echo -e "  Connections: ${CONNS}"
            echo ""
            done < <(echo "${TUNNELS}" | jq -c '.result[]')
  sigma:
    - lang: "yaml"
      filename: "hth-cloudflare-5.01-secure-tunnel-config.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/siem/sigma/hth-cloudflare-5.01-secure-tunnel-config.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    ActionType|contains:
                        - 'CreateTunnel'
                        - 'UpdateTunnel'
                        - 'DeleteTunnel'
                        - 'UpdateTunnelConfiguration'
                condition: selection
              fields:
                - ActorEmail
                - ActionType
                - ResourceID
                - When

"5.2":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-5.02-protect-tunnels-with-access.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-5.02-protect-tunnels-with-access.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_zero_trust_access_application" "tunnel_app" {
            zone_id          = var.cloudflare_zone_id
            name             = "Tunnel-Protected Application"
            domain           = var.app_domain
            type             = "self_hosted"
            session_duration = "8h"
          
            allowed_idps              = [cloudflare_zero_trust_access_identity_provider.corporate_idp.id]
            auto_redirect_to_identity = true
            }
          
            resource "cloudflare_zero_trust_access_policy" "tunnel_app_policy" {
            account_id = var.cloudflare_account_id
            name       = "Allow authenticated employees via tunnel"
            decision   = "allow"
          
            include = [{
              group = {
                id = cloudflare_zero_trust_access_group.employees.id
              }
            }]
          
            require = [{
              auth_method = {
                auth_method = "mfa"
              }
            }]
          
            session_duration = "8h"
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-5.02-protect-tunnels-with-access.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-5.02-protect-tunnels-with-access.sh"
    excerpts:
      api-verify-tunnel-access:
        content: |
            # Cross-reference tunnel hostnames with Access applications
            TUNNELS=$(cf_get "/accounts/${CF_ACCOUNT_ID}/cfd_tunnel?is_deleted=false") || {
            fail "5.2 Unable to retrieve tunnels"
            increment_failed
            summary
            exit 0
            }
          
            APPS=$(cf_get "/accounts/${CF_ACCOUNT_ID}/access/apps") || {
            fail "5.2 Unable to retrieve Access applications"
            increment_failed
            summary
            exit 0
            }
          
            ACCESS_DOMAINS=$(echo "${APPS}" | jq -r '.result[].domain // empty')
            UNPROTECTED=0
          
            while IFS= read -r tunnel; do
            TUNNEL_NAME=$(echo "${tunnel}" | jq -r '.name')
            TUNNEL_ID=$(echo "${tunnel}" | jq -r '.id')
          
            # Get tunnel config to find hostnames
            CONFIG=$(cf_get "/accounts/${CF_ACCOUNT_ID}/cfd_tunnel/${TUNNEL_ID}/configurations") 2>/dev/null || continue
            HOSTNAMES=$(echo "${CONFIG}" | jq -r '.result.config.ingress[]?.hostname // empty' 2>/dev/null || true)
          
            for hostname in ${HOSTNAMES}; do
              [ -z "${hostname}" ] && continue
              if echo "${ACCESS_DOMAINS}" | grep -q "${hostname}"; then
                pass "5.2 Tunnel '${TUNNEL_NAME}' hostname '${hostname}' has Access protection"
              else
                warn "5.2 Tunnel '${TUNNEL_NAME}' hostname '${hostname}' has NO Access policy"
                UNPROTECTED=$((UNPROTECTED + 1))
              fi
            done
            done < <(echo "${TUNNELS}" | jq -c '.result[]')

"6.1":
  terraform:
    lang: "hcl"
    filename: "hth-cloudflare-6.01-configure-logging.tf"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/terraform/hth-cloudflare-6.01-configure-logging.tf"
    excerpts:
      terraform:
        content: |
            resource "cloudflare_logpush_job" "access_requests" {
            account_id       = var.cloudflare_account_id
            name             = "hth-access-requests"
            dataset          = "access_requests"
            destination_conf = var.logpush_destination
            enabled          = true
            frequency        = "high"
            }
          
            resource "cloudflare_logpush_job" "gateway_dns" {
            account_id       = var.cloudflare_account_id
            name             = "hth-gateway-dns"
            dataset          = "gateway_dns"
            destination_conf = var.logpush_destination
            enabled          = true
            frequency        = "high"
            }
          
            resource "cloudflare_logpush_job" "gateway_http" {
            account_id       = var.cloudflare_account_id
            name             = "hth-gateway-http"
            dataset          = "gateway_http"
            destination_conf = var.logpush_destination
            enabled          = true
            frequency        = "high"
            }
          
            resource "cloudflare_logpush_job" "gateway_network" {
            account_id       = var.cloudflare_account_id
            name             = "hth-gateway-network"
            dataset          = "gateway_network"
            destination_conf = var.logpush_destination
            enabled          = true
            frequency        = "high"
            }
  api:
    lang: "bash"
    filename: "hth-cloudflare-6.01-configure-logging.sh"
    source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/api/hth-cloudflare-6.01-configure-logging.sh"
    excerpts:
      api-audit-logpush:
        content: |
            # List all Logpush jobs and check for Zero Trust datasets
            LOGPUSH=$(cf_get "/accounts/${CF_ACCOUNT_ID}/logpush/jobs") || {
            fail "6.1 Unable to retrieve Logpush jobs"
            increment_failed
            summary
            exit 0
            }
          
            JOB_COUNT=$(echo "${LOGPUSH}" | jq '.result | length')
            info "6.1 Found ${JOB_COUNT} Logpush job(s)"
          
            # Check for recommended Zero Trust datasets
            RECOMMENDED_DATASETS=("access_requests" "gateway_dns" "gateway_http" "gateway_network")
            MISSING_DATASETS=()
          
            for dataset in "${RECOMMENDED_DATASETS[@]}"; do
            HAS_DATASET=$(echo "${LOGPUSH}" | jq --arg ds "${dataset}" '[.result[] | select(.dataset == $ds and .enabled == true)] | length')
            if [ "${HAS_DATASET}" -gt 0 ]; then
              pass "6.1 Logpush configured for '${dataset}'"
            else
              warn "6.1 No active Logpush job for '${dataset}'"
              MISSING_DATASETS+=("${dataset}")
            fi
            done
          
            echo "${LOGPUSH}" | jq -r '.result[] | "  - \(.name // "unnamed"): \(.dataset) → \(.destination_conf | split("://")[0]) [\(if .enabled then "enabled" else "disabled" end)]"'
  sigma:
    - lang: "yaml"
      filename: "hth-cloudflare-6.01-configure-logging.yml"
      source_url: "https://github.com/grcengineering/how-to-harden/blob/main/packs/cloudflare/siem/sigma/hth-cloudflare-6.01-configure-logging.yml"
      excerpts:
        detection:
          content: |
              detection:
                selection:
                    ActionType|contains:
                        - 'DeleteLogpushJob'
                        - 'UpdateLogpushJob'
                condition: selection
              fields:
                - ActorEmail
                - ActionType
                - ResourceID
                - When

